<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="Hello World!">
<meta property="og:type" content="website">
<meta property="og:title" content="qicainiao&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="qicainiao&#39;s Blog">
<meta property="og:description" content="Hello World!">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="qicainiao&#39;s Blog">
<meta name="twitter:description" content="Hello World!">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>qicainiao's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">qicainiao's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/28/前端性能优化原理与实践/2网络篇 2：图片优化——质量与性能的博弈/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qicainiao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qicainiao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/28/前端性能优化原理与实践/2网络篇 2：图片优化——质量与性能的博弈/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-28T19:01:07+08:00">
                2019-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="图片优化——质量与性能的博弈"><a href="#图片优化——质量与性能的博弈" class="headerlink" title="图片优化——质量与性能的博弈"></a>图片优化——质量与性能的博弈</h1><p>《高性能网站建设指南》的作者 Steve Souders 曾在 2013 年的一篇 <a href="http://www.stevesouders.com/blog/2013/04/26/i/" target="_blank" rel="noopener">博客</a> 中提到：</p>
<blockquote>
<p>我的大部分性能优化工作都集中在 JavaScript 和 CSS 上，从早期的 Move Scripts to the Bottom 和 Put Stylesheets at the Top 规则。为了强调这些规则的重要性，我甚至说过，“JS 和 CSS 是页面上最重要的部分”。 </p>
<p>几个月后，我意识到这是错误的。图片才是页面上最重要的部分。 </p>
<p>我关注 JS 和 CSS 的重点也是如何能够更快地下载图片。图片是用户可以直观看到的。他们并不会关注 JS 和 CSS。确实，JS 和 CSS 会影响图片内容的展示，尤其是会影响图片的展示方式（比如图片轮播，CSS 背景图和媒体查询）。但是我认为 JS 和 CSS 只是展示图片的方式。在页面加载的过程中，应当先让图片和文字先展示，而不是试图保证 JS 和 CSS 更快下载完成。   </p>
</blockquote>
<p>这段话可谓字字珠玑。此外，雅虎军规和 Google 官方的最佳实践也都将图片优化列为前端性能优化必不可少的环节——图片优化的优先级可见一斑。 </p>
<p>就图片这块来说，与其说我们是在做“优化”，不如说我们是在做“权衡”。因为我们要做的事情，就是去压缩图片的体积（或者一开始就选取体积较小的图片格式）。但这个优化操作，是以牺牲一部分成像质量为代价的。因此我们的主要任务，是尽可能地去寻求一个质量与性能之间的平衡点。    </p>
<h2 id="2018-年，图片依然很大"><a href="#2018-年，图片依然很大" class="headerlink" title="2018 年，图片依然很大"></a>2018 年，图片依然很大</h2><p>这里先给大家介绍 <a href="https://httparchive.org/reports/page-weight#bytesTotal" target="_blank" rel="noopener">HTTP-Archive</a> 这个网站，它会定期抓取 Web 上的站点，并记录资源的加载情况、Web API 的使用情况等页面的详细信息，并会对这些数据进行处理和分析以确定趋势。通过它我们可以实时地看到世界范围内的 Web 资源的统计结果。 </p>
<p>截止到 2018 年 8 月，过去一年<strong>总的 web 资源</strong>的平均请求体积是这样的：   </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/14/165d7a6a7f6a4285?w=2520&h=668&f=png&s=123564" alt>  </p>
<p>而具体到<strong>图片</strong>这一类的资源，平均请求体积是这样的：   </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/14/165d7a930d3eb13f?w=2382&h=638&f=png&s=212908" alt>  </p>
<p>当然，随着我们工程师在性能方面所做的努力越来越有成效，平均来说，不管是资源总量还是图片体积，都在往越来越轻量的方向演化。这是一种值得肯定的进步。 </p>
<p>但同时我们不得不承认，如图所示的这个图片体积，依然是太大了。图片在所有资源中所占的比重，也足够“触目惊心”了。为了改变这个现状，我们必须把图片优化提上日程。    </p>
<h2 id="不同业务场景下的图片方案选型"><a href="#不同业务场景下的图片方案选型" class="headerlink" title="不同业务场景下的图片方案选型"></a>不同业务场景下的图片方案选型</h2><p>时下应用较为广泛的 Web 图片格式有 JPEG/JPG、PNG、WebP、Base64、SVG 等，这些格式都是很有故事的，值得我们好好研究一把。此外，老生常谈的雪碧图（CSS Sprites）至今也仍在一线的前端应用中发光发热，我们也会有所提及。     </p>
<p>不谈业务场景的选型都是耍流氓。下面我们就结合具体的业务场景，一起来解开图片选型的神秘面纱！     </p>
<h3 id="前置知识：二进制位数与色彩的关系"><a href="#前置知识：二进制位数与色彩的关系" class="headerlink" title="前置知识：二进制位数与色彩的关系"></a>前置知识：二进制位数与色彩的关系</h3><p>在计算机中，像素用二进制数来表示。不同的图片格式中像素与二进制位数之间的对应关系是不同的。一个像素对应的二进制位数越多，它可以表示的颜色种类就越多，成像效果也就越细腻，文件体积相应也会越大。    </p>
<p>一个二进制位表示两种颜色（0|1 对应黑|白），如果一种图片格式对应的二进制位数有 n 个，那么它就可以呈现 2^n 种颜色。    </p>
<h3 id="JPEG-JPG"><a href="#JPEG-JPG" class="headerlink" title="JPEG/JPG"></a>JPEG/JPG</h3><p>关键字：<strong>有损压缩、体积小、加载快、不支持透明</strong>     </p>
<h4 id="JPG-的优点"><a href="#JPG-的优点" class="headerlink" title="JPG 的优点"></a>JPG 的优点</h4><p>JPG 最大的特点是<strong>有损压缩</strong>。这种高效的压缩算法使它成为了一种非常轻巧的图片格式。另一方面，即使被称为“有损”压缩，JPG的压缩方式仍然是一种高质量的压缩方式：当我们把图片体积压缩至原有体积的 50% 以下时，JPG 仍然可以保持住 60% 的品质。此外，JPG 格式以 24 位存储单个图，可以呈现多达 1600 万种颜色，足以应对大多数场景下对色彩的要求，这一点决定了它压缩前后的质量损耗并不容易被我们人类的肉眼所察觉——前提是你用对了业务场景。</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>JPG 适用于呈现色彩丰富的图片，在我们日常开发中，JPG 图片经常作为大的背景图、轮播图或 Banner 图出现。</p>
<p>两大电商网站对大图的处理，是 JPG 图片应用场景的最佳写照：      </p>
<p>打开淘宝首页，我们可以发现页面中最醒目、最庞大的图片，一定是以 .jpg 为后缀的： </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/14/165d8aaddff6b9bb?w=2510&h=790&f=png&s=1992144" alt>  </p>
<p>京东首页也不例外：   </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/14/165d8b82ad50c6a4?w=2458&h=1158&f=png&s=2590932" alt></p>
<p>使用 JPG 呈现大图，既可以保住图片的质量，又不会带来令人头疼的图片体积，是当下比较推崇的一种方案。 </p>
<h4 id="JPG-的缺陷"><a href="#JPG-的缺陷" class="headerlink" title="JPG 的缺陷"></a>JPG 的缺陷</h4><p>有损压缩在上文所展示的轮播图上确实很难露出马脚，但当它处理<strong>矢量图形</strong>和 <strong>Logo</strong> 等线条感较强、颜色对比强烈的图像时，人为压缩导致的图片模糊会相当明显。    </p>
<p>此外，JPEG 图像<strong>不支持透明度处理</strong>，透明图片需要召唤 PNG 来呈现。     </p>
<h3 id="PNG-8-与-PNG-24"><a href="#PNG-8-与-PNG-24" class="headerlink" title="PNG-8 与 PNG-24"></a>PNG-8 与 PNG-24</h3><p>关键字：<strong>无损压缩、质量高、体积大、支持透明</strong>   </p>
<h4 id="PNG-的优点"><a href="#PNG-的优点" class="headerlink" title="PNG 的优点"></a>PNG 的优点</h4><p>PNG（可移植网络图形格式）是一种无损压缩的高保真的图片格式。8 和 24，这里都是二进制数的位数。按照我们前置知识里提到的对应关系，8 位的 PNG 最多支持 256 种颜色，而 24 位的可以呈现约 1600 万种颜色。     </p>
<p>PNG 图片具有比 JPG 更强的色彩表现力，对线条的处理更加细腻，对透明度有良好的支持。它弥补了上文我们提到的 JPG 的局限性，唯一的 BUG 就是<strong>体积太大</strong>。   </p>
<h4 id="PNG-8-与-PNG-24-的选择题"><a href="#PNG-8-与-PNG-24-的选择题" class="headerlink" title="PNG-8 与 PNG-24 的选择题"></a>PNG-8 与 PNG-24 的选择题</h4><p>什么时候用 PNG-8，什么时候用 PNG-24，这是一个问题。</p>
<p>理论上来说，当你追求最佳的显示效果、并且不在意文件体积大小时，是推荐使用 PNG-24 的。   </p>
<p>但实践当中，为了规避体积的问题，我们一般不用PNG去处理较复杂的图像。当我们遇到适合 PNG 的场景时，也会优先选择更为小巧的 PNG-8。    </p>
<p>如何确定一张图片是该用 PNG-8 还是 PNG-24 去呈现呢？好的做法是把图片先按照这两种格式分别输出，看 PNG-8 输出的结果是否会带来肉眼可见的质量损耗，并且确认这种损耗是否在我们（尤其是你的 UI 设计师）可接受的范围内，基于对比的结果去做判断。    </p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>前面我们提到，复杂的、色彩层次丰富的图片，用 PNG 来处理的话，成本会比较高，我们一般会交给 JPG 去存储。</p>
<p>考虑到 PNG 在处理线条和颜色对比度方面的优势，我们主要用它来呈现小的 Logo、颜色简单且对比强烈的图片或背景等。</p>
<p>此时我们再次把目光转向性能方面堪称业界楷模的淘宝首页，我们会发现它页面上的 Logo，无论大小，还真的都是 PNG 格式：   </p>
<p>主 Logo：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/15/165db5f3b8a80839?w=1810&h=622&f=png&s=351027" alt>   </p>
<p>较小的 Logo： </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/15/165db6625dbfaae3?w=1426&h=354&f=png&s=116101" alt></p>
<p>颜色简单、对比度较强的透明小图也在 PNG 格式下有着良好的表现： </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/15/165db6c6bcf059ed?w=1434&h=374&f=png&s=177976" alt></p>
<h3 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h3><p>关键字：<strong>文本文件、体积小、不失真、兼容性好</strong>   </p>
<p>SVG（可缩放矢量图形）是一种基于 XML 语法的图像格式。它和本文提及的其它图片种类有着本质的不同：SVG 对图像的处理不是基于像素点，而是是基于对图像的形状描述。   </p>
<h4 id="SVG-的特性"><a href="#SVG-的特性" class="headerlink" title="SVG 的特性"></a>SVG 的特性</h4><p>和性能关系最密切的一点就是：SVG 与 PNG 和 JPG 相比，<strong>文件体积更小，可压缩性更强</strong>。 </p>
<p>当然，作为矢量图，它最显著的优势还是在于<strong>图片可无限放大而不失真</strong>这一点上。这使得 SVG 即使是被放到视网膜屏幕上，也可以一如既往地展现出较好的成像品质——1 张 SVG 足以适配 n 种分辨率。</p>
<p>此外，<strong>SVG 是文本文件</strong>。我们既可以像写代码一样定义 SVG，把它写在 HTML 里、成为 DOM 的一部分，也可以把对图形的描述写入以 .svg 为后缀的独立文件（SVG 文件在使用上与普通图片文件无异）。这使得 SVG 文件可以被非常多的工具读取和修改，具有较强的<strong>灵活性</strong>。       </p>
<p>SVG 的局限性主要有两个方面，一方面是它的渲染成本比较高，这点对性能来说是很不利的。另一方面，SVG 存在着其它图片格式所没有的学习成本（它是可编程的）。</p>
<h4 id="SVG-的使用方式与应用场景"><a href="#SVG-的使用方式与应用场景" class="headerlink" title="SVG 的使用方式与应用场景"></a>SVG 的使用方式与应用场景</h4><p>SVG 是文本文件，我们既可以像写代码一样定义 SVG，把它写在 HTML 里、成为 DOM 的一部分，也可以把对图形的描述写入以 .svg 为后缀的独立文件（SVG 文件在使用上与普通图片文件无异）。 </p>
<ul>
<li>将 SVG 写入 HTML：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2000/svg"</span>   <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">height</span>=<span class="string">"200"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">"50"</span> <span class="attr">cy</span>=<span class="string">"50"</span> <span class="attr">r</span>=<span class="string">"50"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>将 SVG 写入独立文件后引入 HTML:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"文件名.svg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">  ```  </span><br><span class="line"></span><br><span class="line">在实际开发中，我们更多用到的是后者。很多情况下设计师会给到我们 SVG 文件，就算没有设计师，我们还有非常好用的 [在线矢量图形库](http://www.iconfont.cn/)。对于矢量图，我们无须深究过多，只需要对其核心特性有所掌握、日后在应用时做到有迹可循即可。</span><br><span class="line"></span><br><span class="line">### Base64</span><br><span class="line"></span><br><span class="line">关键字：**文本文件、依赖编码、小图标解决方案**      </span><br><span class="line"></span><br><span class="line">Base64 并非一种图片格式，而是一种编码方式。Base64 和雪碧图一样，是作为小图标解决方案而存在的。在了解 Base64 之前，我们先来了解一下雪碧图。</span><br><span class="line"></span><br><span class="line">#### 前置知识：最经典的小图标解决方案——雪碧图（CSS Sprites）  </span><br><span class="line"></span><br><span class="line">雪碧图、CSS 精灵、CSS Sprites、图像精灵，说的都是这个东西——一种将小图标和背景图像合并到一张图片上，然后利用 CSS 的背景定位来显示其中的每一部分的技术。   </span><br><span class="line">   </span><br><span class="line">MDN 对雪碧图的解释已经非常到位：</span><br><span class="line"></span><br><span class="line">&gt; 图像精灵（sprite，意为精灵），被运用于众多使用大量小图标的网页应用之上。它可取图像的一部分来使用，使得使用一个图像文件替代多个小文件成为可能。相较于一个小图标一个图像文件，单独一张图片所需的 HTTP 请求更少，对内存和带宽更加友好。 </span><br><span class="line">  </span><br><span class="line">我们几乎可以在每一个有小图标出现的网站里找到雪碧图的影子（下图截取自京东首页）： </span><br><span class="line"></span><br><span class="line">![](https://user-gold-cdn.xitu.io/2018/9/15/165dbe673eba8fba?w=1212&amp;h=444&amp;f=png&amp;s=135406)    </span><br><span class="line"></span><br><span class="line">和雪碧图一样，Base64 图片的出现，也是为了减少加载网页图片时对服务器的请求次数，从而提升网页性能。**Base64 是作为雪碧图的补充而存在的。**   </span><br><span class="line">#### 理解 Base64</span><br><span class="line"></span><br><span class="line">通过我们上文的演示，大家不难看出，每次加载图片，都是需要单独向服务器请求这个图片对应的资源的——这也就意味着一次 HTTP 请求的开销。</span><br><span class="line"></span><br><span class="line">**Base64 是一种用于传输 8Bit 字节码的编码方式，通过对图片进行 Base64 编码，我们可以直接将编码结果写入 HTML 或者写入 CSS，从而减少 HTTP 请求的次数。**  </span><br><span class="line"></span><br><span class="line">我们来一起看一个实例，现在我有这么一个小小的放大镜 Logo： </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin: 20px auto; text-align:center; border:1px solid #bbb"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://user-gold-cdn.xitu.io/2018/9/15/165db7e94699824b?w=22&amp;h=22&amp;f=png&amp;s=3680"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">它对应的链接如下：</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><a href="https://user-gold-cdn.xitu.io/2018/9/15/165db7e94699824b?w=22&amp;h=22&amp;f=png&amp;s=3680" target="_blank" rel="noopener">https://user-gold-cdn.xitu.io/2018/9/15/165db7e94699824b?w=22&amp;h=22&amp;f=png&amp;s=3680</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">按照一贯的思路，我们加载图片需要把图片链接写入 img 标签：   </span><br><span class="line">```html</span><br><span class="line">&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/9/15/165db7e94699824b?w=22&amp;h=22&amp;f=png&amp;s=3680&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>浏览器就会针对我们的图片链接去发起一个资源请求。 </p>
<p>但是如果我们对这个图片进行 Base64 编码，我们会得到一个这样的字符串： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAYAAADEtGw7AAAMJGlDQ1BJQ0MgUHJvZmlsZQAASImVlwdUU8kagOeWJCQktEAEpITeBCnSpdfQpQo2QhJIKDEkBBU7uqjgWlARwYquitjWAshiw14Wwd4fiKgo62LBhsqbFNDV89477z9n7v3yzz9/mcydMwOAehxbJMpFNQDIExaI48MCmeNT05ikR4AECIAKRgEamyMRBcTFRQEoQ+9/yrubAJG9r9nLfP3c/19Fk8uTcABA4iBncCWcPMiHAMDdOCJxAQCEXqg3m1YggkyEWQJtMUwQsrmMsxTsIeMMBUfJbRLjgyCnA6BCZbPFWQCoyfJiFnKyoB+1pZAdhVyBEHIzZF8On82F/BnyqLy8qZDVrSFbZ3znJ+sfPjOGfbLZWcOsqEUuKsECiSiXPeP/nI7/LXm50qEYZrBR+eLweFnNsnnLmRopYyrk88KMmFjIWpCvC7hyexk/4UvDk5T2HziSIDhngAEASuWygyMhG0A2FebGRCn1vpmCUBZkOPdooqCAlagYi3LFU+OV/tHpPElIwhCzxfJYMptSaU5SgNLnRj6PNeSzqYifmKLIE20rFCTHQFaDfF+SkxCptHlexA+KGbIRS+NlOcP/HAOZ4tB4hQ1mnicZqgvz4gtYMUqO4rDl+ehCnlzATwxX+MEKeZLxUUN5cnnBIYq6sGKeMEmZP1YuKgiMV47dJsqNU9pjzbzcMJneFHKrpDBhaGxfAVxsinpxICqIS1TkhmtnsyPiFHFxWxAFgkAwYAIpbBlgKsgGgtbehl74S9ETCthADLIAD9grNUMjUuQ9QvhMAEXgL0g8IBkeFyjv5YFCqP8yrFU87UGmvLdQPiIHPIGcByJBLvwtlY8SDkdLBo+hRvBTdA7MNRc2Wd9POqb6kI4YQgwmhhNDiTa4Pu6Le+NR8OkPmzPugXsO5fXNnvCE0E54RLhB6CDcmSIoFv+QORNEgw6YY6iyuozvq8MtoVdXPBD3gf6hb5yB6wN7fAyMFID7wdiuUPt9rtLhir/NpdIX2ZGMkkeQ/cnWP2Ugm53v61fq1WzVXJV5ZQzPVtCw1Y9egr6bPy58R/5oiS3GDmLnsJPYBawZawBM7DjWiF3Gjsp4eG08lq+NoWjx8txyoB/BT/HYypiyWZM41jn2OH5W9oEC3vQC2ccSNFU0QyzI4hcwA+BuzWOyhByHUUxnRye4i8r2fsXW8oYh39MRxsVvuvwTAHiWQmXWNx0b7kFHngBAf/dNZ/YaLvsVABxt40jFhQodLnsQAAWowy9FDxjBvcsaVuQM3IA38AchIALEgkSQCibDOefDdSoG08AsMB+UgDKwAqwBVWAT2Ap2gj3gAGgAzeAkOAsugTZwA9yDa6UbvAB94B0YQBCEhNAQOqKHGCMWiB3ijHggvkgIEoXEI6lIOpKFCBEpMgtZgJQh5UgVsgWpRX5HjiAnkQtIO3IH6UR6kNfIJxRDqag2aohaoqNRDzQAjUQT0UloFpqPFqEL0WVoJVqD7kbr0ZPoJfQG2oG+QPsxgKliDMwEs8c8sCAsFkvDMjExNgcrxSqwGmwv1gT/6WtYB9aLfcSJOB1n4vZwvYbjSTgHz8fn4EvxKnwnXo+fxq/hnXgf/pVAIxgQ7AheBBZhPCGLMI1QQqggbCccJpyB30434R2RSGQQrYju8NtLJWYTZxKXEjcQ9xFPENuJXcR+EomkR7Ij+ZBiSWxSAamEtI60m3ScdJXUTfqgoqpirOKsEqqSpiJUKVapUNmlckzlqspTlQGyBtmC7EWOJXPJM8jLydvITeQr5G7yAEWTYkXxoSRSsinzKZWUvZQzlPuUN6qqqqaqnqrjVAWq81QrVfernlftVP1I1aLaUoOoE6lS6jLqDuoJ6h3qGxqNZknzp6XRCmjLaLW0U7SHtA9qdDUHNZYaV22uWrVavdpVtZfqZHUL9QD1yepF6hXqB9WvqPdqkDUsNYI02BpzNKo1jmjc0ujXpGs6acZq5mku1dyleUHzmRZJy1IrRIurtVBrq9YprS46RjejB9E59AX0bfQz9G5toraVNks7W7tMe492q3afjpbOGJ1knek61TpHdToYGMOSwWLkMpYzDjBuMj6NMBwRMII3YsmIvSOujnivO1LXX5enW6q7T/eG7ic9pl6IXo7eSr0GvQf6uL6t/jj9afob9c/o947UHuk9kjOydOSBkXcNUANbg3iDmQZbDS4b9BsaGYYZigzXGZ4y7DViGPkbZRutNjpm1GNMN/Y1FhivNj5u/Jypwwxg5jIrmaeZfSYGJuEmUpMtJq0mA6ZWpkmmxab7TB+YUcw8zDLNVpu1mPWZG5tHm88yrzO/a0G28LDgW6y1OGfx3tLKMsVykWWD5TMrXSuWVZFVndV9a5q1n3W+dY31dRuijYdNjs0GmzZb1NbVlm9bbXvFDrVzsxPYbbBrH0UY5TlKOKpm1C17qn2AfaF9nX2nA8MhyqHYocHh5Wjz0WmjV44+N/qro6tjruM2x3tOWk4RTsVOTU6vnW2dOc7VztddaC6hLnNdGl1ejbEbwxuzccxtV7prtOsi1xbXL27ubmK3vW497ubu6e7r3W95aHvEeSz1OO9J8Az0nOvZ7PnRy82rwOuA19/e9t453ru8n421Gssbu21sl4+pD9tni0+HL9M33Xezb4efiR/br8bvkb+ZP9d/u//TAJuA7IDdAS8DHQPFgYcD3wd5Bc0OOhGMBYcFlwa3hmiFJIVUhTwMNQ3NCq0L7QtzDZsZdiKcEB4ZvjL8FsuQxWHVsvoi3CNmR5yOpEYmRFZFPoqyjRJHNUWj0RHRq6Lvx1jECGMaYkEsK3ZV7IM4q7j8uD/GEcfFjase9yTeKX5W/LkEesKUhF0J7xIDE5cn3kuyTpImtSSrJ09Mrk1+nxKcUp7SMX70+NnjL6XqpwpSG9NIaclp29P6J4RMWDOhe6LrxJKJNydZTZo+6cJk/cm5k49OUZ/CnnIwnZCekr4r/TM7ll3D7s9gZazP6OMEcdZyXnD9uau5PTwfXjnvaaZPZnnmsyyfrFVZPXw/fgW/VxAkqBK8yg7P3pT9Pic2Z0fOYG5K7r48lbz0vCNCLWGO8PRUo6nTp7aL7EQloo58r/w1+X3iSPF2CSKZJGks0IaH7MtSa+kv0s5C38Lqwg/TkqcdnK45XTj98gzbGUtmPC0KLfptJj6TM7Nllsms+bM6ZwfM3jIHmZMxp2Wu2dyFc7vnhc3bOZ8yP2f+n8WOxeXFbxekLGhaaLhw3sKuX8J+qStRKxGX3FrkvWjTYnyxYHHrEpcl65Z8LeWWXixzLKso+7yUs/Tir06/Vv46uCxzWetyt+UbVxBXCFfcXOm3cme5ZnlRedeq6FX1q5mrS1e/XTNlzYWKMRWb1lLWStd2VEZVNq4zX7di3ecqftWN6sDqfesN1i9Z/34Dd8PVjf4b924y3FS26dNmwebbW8K21NdY1lRsJW4t3PpkW/K2c795/Fa7XX972fYvO4Q7OnbG7zxd615bu8tg1/I6tE5a17N74u62PcF7Gvfa792yj7GvbD/YL93//Pf0328eiDzQctDj4N5DFofWH6YfLq1H6mfU9zXwGzoaUxvbj0QcaWnybjr8h8MfO5pNmquP6hxdfoxybOGxweNFx/tPiE70nsw62dUypeXeqfGnrp8ed7r1TOSZ82dDz546F3Du+Hmf880XvC4cuehxseGS26X6y66XD//p+ufhVrfW+ivuVxrbPNua2se2H7vqd/XkteBrZ6+zrl+6EXOj/WbSzdu3Jt7quM29/exO7p1XdwvvDtybd59wv/SBxoOKhwYPa/5l8699HW4dRzuDOy8/Snh0r4vT9eKx5PHn7oVPaE8qnho/rX3m/Ky5J7Sn7fmE590vRC8Gekv+0vxr/Uvrl4f+9v/7ct/4vu5X4leDr5e+0Xuz4+2Yty39cf0P3+W9G3hf+kHvw86PHh/PfUr59HRg2mfS58ovNl+avkZ+vT+YNzgoYovZ8qMABhuamQnA6x0A0FLh2aENAMoExd1MLojiPikn8J9YcX+TixsAO/wBSJoHQBQ8o2yEzQIyFb5lR/BEf4C6uAw3pUgyXZwVvqjwxkL4MDj4xhAAUhMAX8SDgwMbBge/bIPJ3gHgRL7iTigT2R10s4OM2rpfgh/l34RUcT2MnhaNAAAB90lEQVQ4Ee1Tv0tbURQ+5yVqFVHs4pBioSAp1mAxUdq05sfoKrh072QXN6HdnMTVyboLShH8D+xLg8UkhjY/tJlERIQilCpKfbmn3w08eOTdl83Nu5x7z/m+737vnHeJHtZ9d4CDLhARK1esfSChWWF6TSQnRLwnSq2mp2OnQTw3bxS2D349I77bAijuAt0oJNfEtJiKj392c6ZotSfhFJfdfUE+jn1eWZwe6HL6Q0yjqHyE6zALr+eK9bl2rvfsc2wXKwskvAZQbibxYsYL1nu7UJ1H2BKiq+bfsaFslp12jD4bHHPLCdwumQi4bBuiP+Gov3vwaMqEMQqz6EER9fHjwyASMGVdU6KeB2F8jjH9cw2+sS5Hg0jodUTXRNFlEMYvzPyjBVa0YCLZpcoE2pBBTYmokgmjcz5hZl7RJEz/vV2oLDcajR6XvHdYT0qTdzQPfd7s9D/7/gotYhdqn/Chy3ovQrfMVMUwh3HpE51rLaGqw+FMNhH97aa80SisAblC9R1EN/AYej0EpGgXpARyEbzKY4i/NYkHCmux/f3GgBP6l8EjiVp40nD8/c3k2Mm3Uu2pUvIVkBEt3vVIpV/FYhea466Owi7IFPPl40jTcfKojaBNB6mp8Wkvzjc8b7HTPvkyehYKh5NwXGbiP52wD7X76cB/EiWtaCMHwyUAAAAASUVORK5CYII=</span><br></pre></td></tr></table></figure>

<p>字符串比较长，我们可以直接用这个字符串替换掉上文中的链接地址。你会发现浏览器原来是可以理解这个字符串的，它自动就将这个字符串解码为了一个图片，而不需再去发送 HTTP 请求。   </p>
<h4 id="Base64-的应用场景"><a href="#Base64-的应用场景" class="headerlink" title="Base64 的应用场景"></a>Base64 的应用场景</h4><p>上面这个实例，其实源自我们 <a href="https://juejin.im/books" target="_blank" rel="noopener">掘金</a> 网站 Header 部分的搜索栏 Logo：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/15/165db8e1ea0594b7?w=542&h=124&f=png&s=10413" alt> </p>
<p>大家不妨打开小册首页，然后打开开发者工具，在源码中搜索“base64”关键字，你会发现 Base64 码出现的地方真的不少。而且它对应的图片往往是<strong>非常小的 Logo</strong>。  </p>
<p>既然 Base64 这么棒，我们何不把大图也换成 Base64 呢？</p>
<p>这是因为，Base64 编码后，图片大小会膨胀为原文件的 4/3（这是由 Base64 的编码原理决定的）。如果我们把大图也编码到 HTML 或 CSS 文件中，后者的体积会明显增加，即便我们减少了 HTTP 请求，也无法弥补这庞大的体积带来的性能开销，得不偿失。<br>在传输非常小的图片的时候，Base64 带来的文件体积膨胀、以及浏览器解析 Base64 的时间开销，与它节省掉的 HTTP 请求开销相比，可以忽略不计，这时候才能真正体现出它在性能方面的优势。    </p>
<p>因此，Base64 并非万全之策，我们往往在一张图片满足以下条件时会对它应用 Base64 编码：</p>
<ul>
<li>图片的实际尺寸很小（大家可以观察一下掘金页面的 Base64 图，几乎没有超过 2kb 的）</li>
<li>图片无法以雪碧图的形式与其它小图结合（合成雪碧图仍是主要的减少 HTTP 请求的途径，Base64 是雪碧图的补充）</li>
<li>图片的更新频率非常低（不需我们重复编码和修改文件内容，维护成本较低）</li>
</ul>
<h4 id="Base64-编码工具推荐"><a href="#Base64-编码工具推荐" class="headerlink" title="Base64 编码工具推荐"></a>Base64 编码工具推荐</h4><p>这里最推荐的是利用 webpack 来进行 Base64 的编码——webpack 的 <a href="https://github.com/webpack-contrib/url-loader" target="_blank" rel="noopener">url-loader</a> 非常聪明，它除了具备基本的 Base64 转码能力，还可以结合文件大小，帮我们判断图片是否有必要进行 Base64 编码。   </p>
<p>除此之外，市面上免费的 Base64 编解码工具种类是非常多样化的，有很多网站都提供在线编解码的服务，大家选取自己认为顺手的工具就好。    </p>
<h3 id="WebP"><a href="#WebP" class="headerlink" title="WebP"></a>WebP</h3><p>关键字：<strong>年轻的全能型选手</strong>    </p>
<p>WebP 是今天在座各类图片格式中最年轻的一位，它于 2010 年被提出，<br>是 Google 专为 Web 开发的一种<strong>旨在加快图片加载速度</strong>的图片格式，它支持有损压缩和无损压缩。    </p>
<h4 id="WebP-的优点"><a href="#WebP-的优点" class="headerlink" title="WebP 的优点"></a>WebP 的优点</h4><p>WebP 像 JPEG 一样对细节丰富的图片信手拈来，像 PNG 一样支持透明，像 GIF 一样可以显示动态图片——它集多种图片文件格式的优点于一身。<br>WebP 的官方介绍对这一点有着更权威的阐述： </p>
<blockquote>
<p>与 PNG 相比，WebP 无损图像的尺寸缩小了 26％。在等效的 SSIM 质量指数下，WebP 有损图像比同类 JPEG 图像小 25-34％。<br>无损 WebP 支持透明度（也称为 alpha 通道），仅需 22％ 的额外字节。对于有损 RGB 压缩可接受的情况，有损 WebP 也支持透明度，与 PNG 相比，通常提供 3 倍的文件大小。   </p>
</blockquote>
<p>我们开篇提到，图片优化是质量与性能的博弈，从这个角度看，WebP 无疑是真正的赢家。  </p>
<h4 id="WebP-的局限性"><a href="#WebP-的局限性" class="headerlink" title="WebP 的局限性"></a>WebP 的局限性</h4><p>WebP 纵有千般好，但它毕竟<strong>太年轻</strong>。我们知道，任何新生事物，都逃不开兼容性的大坑。现在是 2018 年 9 月，WebP 的支持情况是这样的：  </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/15/165dd3619608be39?w=2538&h=998&f=png&s=194980" alt> </p>
<p>坦白地说，虽然没有特别惨（毕竟还有亲爹 Chrome 在撑腰），但也足够让人望而却步了。 </p>
<p>此外，WebP 还会增加服务器的负担——和编码 JPG 文件相比，编码同样质量的 WebP 文件会占用更多的计算资源。</p>
<h4 id="WebP-的应用场景"><a href="#WebP-的应用场景" class="headerlink" title="WebP 的应用场景"></a>WebP 的应用场景</h4><p>现在限制我们使用 WebP 的最大问题不是“这个图片是否适合用 WebP 呈现”的问题，而是“浏览器是否允许 WebP”的问题，即我们上文谈到的兼容性问题。具体来说，一旦我们选择了 WebP，就要考虑在 Safari 等浏览器下它无法显示的问题，也就是说我们需要准备 PlanB，准备降级方案。 </p>
<p>目前真正把 WebP 格式落地到网页中的网站并不是很多，这其中淘宝首页对 WebP 兼容性问题的处理方式就非常有趣。我们可以打开 Chrome 的开发者工具搜索其源码里的 WebP 关键字：    </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/15/165dd62ed2bde93e?w=1240&h=420&f=png&s=117980" alt>  </p>
<p>我们会发现检索结果还是挺多的（单就图示的加载结果来看，足足有　200　多条），下面大家注意一下这些 WebP 图片的链接地址（以其中一个为例）：   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;//img.alicdn.com/tps/i4/TB1CKSgIpXXXXccXXXX07tlTXXX-200-200.png_60x60.jpg_.webp&quot; alt=&quot;手机app - 聚划算&quot; class=&quot;app-icon&quot;&gt;</span><br><span class="line">```   </span><br><span class="line">.webp 前面，还跟了一个 .jpg 后缀！  </span><br><span class="line"></span><br><span class="line">我们现在先大胆地猜测，这个图片应该至少存在 jpg 和 webp 两种格式，程序会根据浏览器的型号、以及该型号是否支持 WebP 这些信息来决定当前浏览器显示的是 .webp 后缀还是 .jpg 后缀。带着这个预判，我们打开并不支持 WebP 格式的 Safari 来进入同样的页面，再次搜索 WebP 关键字：</span><br><span class="line"></span><br><span class="line">&lt;div style=&quot;margin: 20px auto; text-align:center; border:1px solid #bbb&quot;&gt;</span><br><span class="line">  &lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/9/15/165dd6aa9ffcf484?w=872&amp;h=126&amp;f=png&amp;s=32866&quot; width=360&quot;&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">Safari 提示我们找不到，这也是情理之中。我们定位到刚刚示例的 WebP 图片所在的元素，查看一下它在 Safari 里的图片链接：</span><br></pre></td></tr></table></figure>

<img src="//img.alicdn.com/tps/i4/TB1CKSgIpXXXXccXXXX07tlTXXX-200-200.png_60x60.jpg" alt="手机app - 聚划算" class="app-icon">
```

<p>我们看到同样的一张图片，在 Safari 中的后缀从 .webp 变成了 .jpg！看来果然如此——站点确实是先进行了兼容性的预判，在浏览器环境支持 WebP 的情况下，优先使用 WebP 格式，否则就把图片降级为 JPG 格式（本质是对图片的链接地址作简单的字符串切割）。    </p>
<p>此外，还有另一个维护性更强、更加灵活的方案——把判断工作交给后端，由服务器根据 HTTP 请求头部的 Accept 字段来决定返回什么格式的图片。当 Accept 字段包含 image/webp 时，就返回 WebP 格式的图片，否则返回原图。这种做法的好处是，当浏览器对 WebP 格式图片的兼容支持发生改变时，我们也不用再去更新自己的兼容判定代码，只需要服务端像往常一样对 Accept 字段进行检查即可。</p>
<p>由此也可以看出，我们 WebP 格式的局限性确实比较明显，如果决定使用 WebP，兼容性处理是必不可少的。    </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>不知道大家有没有注意到这一点：在图片这一节，我用到的许多案例图示，都是源于一线的电商网站。</p>
<p>为什么这么做？因为图片是电商平台的重要资源，甚至有人说“做电商就是做图片”。淘宝和京东，都是流量巨大、技术成熟的站点，它们在性能优化方面起步早、成效好，很多方面说是教科书般的案例也不为过。    </p>
<p>这也是非常重要的一个学习方法。在小册开篇我提到，性能优化不那么好学，有很大原因是因为这块的知识不成体系、难以切入，同时技术方案又迭代得飞快。当我们不知道怎么切入的时候，或者说当我们面对一个具体的问题无从下手的时候，除了翻阅手中的书本（很可能是已经过时的）和网络上收藏的文章（也许没那么权威），现在是不是又多了“打开那些优秀的网站看一看”这条路可以走了呢？ </p>
<p>好了，至此，我们终于结束了图片优化的征程。下面，我们以存储篇为过渡，进入 JS 和 CSS 的世界！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/28/前端性能优化原理与实践/4存储篇 2：本地存储——从 Cookie 到 Web Storage、IndexDB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qicainiao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qicainiao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/28/前端性能优化原理与实践/4存储篇 2：本地存储——从 Cookie 到 Web Storage、IndexDB/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-28T19:01:07+08:00">
                2019-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="本地存储——从-Cookie-到-Web-Storage、IndexDB"><a href="#本地存储——从-Cookie-到-Web-Storage、IndexDB" class="headerlink" title="本地存储——从 Cookie 到 Web Storage、IndexDB"></a>本地存储——从 Cookie 到 Web Storage、IndexDB</h1><p>随着移动网络的发展与演化，我们手机上现在除了有原生 App，还能跑“WebApp”——它即开即用，用完即走。一个优秀的 WebApp 甚至可以拥有和原生 App 媲美的功能和体验。 </p>
<p>我认为，WebApp 就是我们前端性能优化的产物，是我们前端工程师对体验不懈追求的结果，是 Web 网页在性能上向 Native 应用的一次“宣战”。</p>
<p>WebApp 优异的性能表现，要归功于浏览器存储技术的广泛应用——这其中除了我们上节提到的缓存，本地存储技术也功不可没。        </p>
<h2 id="故事的开始：从-Cookie-说起"><a href="#故事的开始：从-Cookie-说起" class="headerlink" title="故事的开始：从 Cookie 说起"></a>故事的开始：从 Cookie 说起</h2><p>Cookie 的本职工作并非本地存储，而是“维持状态”。</p>
<p>在 Web 开发的早期，人们亟需解决的一个问题就是状态管理的问题：HTTP 协议是一个无状态协议，服务器接收客户端的请求，返回一个响应，故事到此就结束了，服务器并没有记录下关于客户端的任何信息。那么下次请求的时候，如何让服务器知道“我是我”呢？ </p>
<p>在这样的背景下，Cookie 应运而生。</p>
<p>Cookie 说白了就是一个存储在浏览器里的一个小小的文本文件，它附着在 HTTP 请求上，在浏览器和服务器之间“飞来飞去”。它可以携带用户信息，当服务器检查 Cookie 的时候，便可以获取到客户端的状态。</p>
<p>关于 Cookie 的详细内容，我们可以在 Chrome 的 Application 面板中查看到：  </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/22/166002bebabcf363?w=1916&h=904&f=png&s=257061" alt>  </p>
<p>如大家所见，<strong>Cookie 以键值对的形式存在</strong>。    </p>
<h3 id="Cookie的性能劣势"><a href="#Cookie的性能劣势" class="headerlink" title="Cookie的性能劣势"></a>Cookie的性能劣势</h3><h4 id="Cookie-不够大"><a href="#Cookie-不够大" class="headerlink" title="Cookie 不够大"></a>Cookie 不够大</h4><p>大家知道，Cookie 是有体积上限的，它最大只能有 4KB。当 Cookie 超过 4KB 时，它将面临被裁切的命运。这样看来，Cookie 只能用来存取少量的信息。 </p>
<h4 id="过量的-Cookie-会带来巨大的性能浪费"><a href="#过量的-Cookie-会带来巨大的性能浪费" class="headerlink" title="过量的 Cookie 会带来巨大的性能浪费"></a>过量的 Cookie 会带来巨大的性能浪费</h4><p><strong>Cookie 是紧跟域名的</strong>。我们通过响应头里的 Set-Cookie 指定要存储的 Cookie 值。默认情况下，domain 被设置为设置 Cookie 页面的主机名，我们也可以手动设置 domain 的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: name=xiuyan; domain=xiuyan.me</span><br></pre></td></tr></table></figure>


<p><strong>同一个域名下的所有请求，都会携带 Cookie</strong>。大家试想，如果我们此刻仅仅是请求一张图片或者一个 CSS 文件，我们也要携带一个 Cookie 跑来跑去（关键是 Cookie 里存储的信息我现在并不需要），这是一件多么劳民伤财的事情。Cookie 虽然小，请求却可以有很多，随着请求的叠加，这样的不必要的 Cookie 带来的开销将是无法想象的。     </p>
<p>随着前端应用复杂度的提高，Cookie 也渐渐演化为了一个“存储多面手”——它不仅仅被用于维持状态，还被塞入了一些乱七八糟的其它信息，被迫承担起了本地存储的“重任”。在没有更好的本地存储解决方案的年代里，Cookie 小小的身体里承载了 4KB 内存所不能承受的压力。 </p>
<p>为了弥补 Cookie 的局限性，让“专业的人做专业的事情”，Web Storage 出现了。   </p>
<h2 id="向前一步：Web-Storage"><a href="#向前一步：Web-Storage" class="headerlink" title="向前一步：Web Storage"></a>向前一步：Web Storage</h2><p>Web Storage 是 HTML5 专门为浏览器存储而提供的数据存储机制。它又分为 Local Storage 与 Session Storage。这两组概念非常相近，我们不妨先理解它们之间的区别，再对它们的共性进行研究。   </p>
<h3 id="Local-Storage-与-Session-Storage-的区别"><a href="#Local-Storage-与-Session-Storage-的区别" class="headerlink" title="Local Storage 与 Session Storage 的区别"></a>Local Storage 与 Session Storage 的区别</h3><p>两者的区别在于<strong>生命周期</strong>与<strong>作用域</strong>的不同。</p>
<ul>
<li><p>生命周期：Local Storage 是持久化的本地存储，存储在其中的数据是永远不会过期的，使其消失的唯一办法是手动删除；而 Session Storage 是临时性的本地存储，它是会话级别的存储，当会话结束（页面被关闭）时，存储内容也随之被释放。 </p>
</li>
<li><p>作用域：Local Storage、Session Storage 和 Cookie 都遵循同源策略。但 Session Storage 特别的一点在于，即便是相同域名下的两个页面，只要它们<strong>不在同一个浏览器窗口中</strong>打开，那么它们的 Session Storage 内容便无法共享。   </p>
</li>
</ul>
<h3 id="Web-Storage-的特性"><a href="#Web-Storage-的特性" class="headerlink" title="Web Storage 的特性"></a>Web Storage 的特性</h3><ul>
<li><p>存储容量大： Web Storage 根据浏览器的不同，存储容量可以达到 5-10M 之间。 </p>
</li>
<li><p>仅位于浏览器端，不与服务端发生通信。</p>
</li>
</ul>
<h3 id="Web-Storage-核心-API-使用示例"><a href="#Web-Storage-核心-API-使用示例" class="headerlink" title="Web Storage 核心 API 使用示例"></a>Web Storage 核心 API 使用示例</h3><p>Web Storage 保存的数据内容和 Cookie 一样，是文本内容，以键值对的形式存在。Local Storage 与 Session Storage 在 API 方面无异，这里我们以 localStorage 为例： </p>
<ul>
<li>存储数据：setItem()</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(<span class="string">'user_name'</span>, <span class="string">'xiuyan'</span>)</span><br></pre></td></tr></table></figure>


<ul>
<li>读取数据： getItem()</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.getItem(<span class="string">'user_name'</span>)</span><br></pre></td></tr></table></figure>


<ul>
<li>删除某一键名对应的数据： removeItem()</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.removeItem(<span class="string">'user_name'</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>清空数据记录：clear()</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.clear()</span><br></pre></td></tr></table></figure>


<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="Local-Storage"><a href="#Local-Storage" class="headerlink" title="Local Storage"></a>Local Storage</h4><p>Local Storage 在存储方面没有什么特别的限制，理论上 Cookie 无法胜任的、可以用简单的键值对来存取的数据存储任务，都可以交给 Local Storage 来做。</p>
<p>这里给大家举个例子，考虑到 Local Storage 的特点之一是<strong>持久</strong>，有时我们更倾向于用它来存储一些内容稳定的资源。比如图片内容丰富的电商网站会用它来存储 Base64 格式的图片字符串： </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/22/16600d07e6abdd81?w=1980&h=518&f=png&s=278919" alt> </p>
<p>有的网站还会用它存储一些不经常更新的 CSS、JS 等静态资源。      </p>
<h4 id="Session-Storage"><a href="#Session-Storage" class="headerlink" title="Session Storage"></a>Session Storage</h4><p>Session Storage 更适合用来存储生命周期和它同步的<strong>会话级别</strong>的信息。这些信息只适用于当前会话，当你开启新的会话时，它也需要相应的更新或释放。比如微博的 Session Storage 就主要是存储你本次会话的浏览足迹：   </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/29/16623d7a9457d1df?w=1597&h=696&f=jpeg&s=68226" alt></p>
<p>lasturl 对应的就是你上一次访问的 URL 地址，这个地址是即时的。当你切换 URL 时，它随之更新，当你关闭页面时，留着它也确实没有什么意义了，干脆释放吧。这样的数据用 Session Storage 来处理再合适不过。     </p>
<p>这样看来，Web Storage 确实也够强大了。那么 Web Storage 是否能 hold 住所有的存储场景呢？  </p>
<p>答案是否定的。大家也看到了，Web Storage 是一个从定义到使用都非常简单的东西。它使用键值对的形式进行存储，这种模式有点类似于对象，却甚至连对象都不是——它只能存储字符串，要想得到对象，我们还需要先对字符串进行一轮解析。</p>
<p>说到底，Web Storage 是对 Cookie 的拓展，它只能用于存储少量的简单数据。当遇到大规模的、结构复杂的数据时，Web Storage 也爱莫能助了。这时候我们就要清楚我们的终极大 boss——IndexDB！</p>
<h2 id="终极形态：IndexDB"><a href="#终极形态：IndexDB" class="headerlink" title="终极形态：IndexDB"></a>终极形态：IndexDB</h2><p>IndexDB 是一个<strong>运行在浏览器上的非关系型数据库</strong>。既然是数据库了，那就不是 5M、10M 这样小打小闹级别了。理论上来说，IndexDB 是没有存储上限的（一般来说不会小于 250M）。它不仅可以存储字符串，还可以存储二进制数据。   </p>
<p>IndexDB 从推出之日起，其优质教程就层出不绝，我们今天不再着重讲解它的详细操作。接下来，我们遵循 MDN 推荐的操作模式，通过一个基本的 IndexDB 使用流程，旨在对 IndexDB 形成一个感性的认知：</p>
<ol>
<li>打开/创建一个 IndexDB 数据库（当该数据库不存在时，open 方法会直接创建一个名为 xiaoceDB 新数据库）。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后面的回调中，我们可以通过event.target.result拿到数据库实例</span></span><br><span class="line"><span class="keyword">let</span> db</span><br><span class="line"><span class="comment">// 参数1位数据库名，参数2为版本号</span></span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">window</span>.indexedDB.open(<span class="string">"xiaoceDB"</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 使用IndexDB失败时的监听函数</span></span><br><span class="line">request.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'无法使用IndexDB'</span>)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 成功</span></span><br><span class="line">request.onsuccess  = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 此处就可以获取到db实例</span></span><br><span class="line">  db = event.target.result</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"你打开了IndexDB"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="2">
<li><p>创建一个 object store（object store 对标到数据库中的“表”单位）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onupgradeneeded事件会在初始化数据库/版本发生更新时被调用，我们在它的监听函数中创建object store</span></span><br><span class="line">request.onupgradeneeded = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> objectStore</span><br><span class="line">  <span class="comment">// 如果同名表未被创建过，则新建test表</span></span><br><span class="line">  <span class="keyword">if</span> (!db.objectStoreNames.contains(<span class="string">'test'</span>)) &#123;</span><br><span class="line">    objectStore = db.createObjectStore(<span class="string">'test'</span>, &#123; <span class="attr">keyPath</span>: <span class="string">'id'</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构建一个事务来执行一些数据库操作，像增加或提取数据等。</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建事务，指定表格名称和读写权限</span></span><br><span class="line"><span class="keyword">const</span> transaction = db.transaction([<span class="string">"test"</span>],<span class="string">"readwrite"</span>)</span><br><span class="line"><span class="comment">// 拿到Object Store对象</span></span><br><span class="line"><span class="keyword">const</span> objectStore = transaction.objectStore(<span class="string">"test"</span>)</span><br><span class="line"><span class="comment">// 向表格写入数据</span></span><br><span class="line">objectStore.add(&#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'xiuyan'</span>&#125;)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>通过监听正确类型的事件以等待操作完成。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 操作成功时的监听函数</span></span><br><span class="line">transaction.oncomplete = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"操作成功"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 操作失败时的监听函数</span></span><br><span class="line">transaction.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"这里有一个Error"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="IndexDB-的应用场景"><a href="#IndexDB-的应用场景" class="headerlink" title="IndexDB 的应用场景"></a>IndexDB 的应用场景</h3><p>通过上面的示例大家可以看出，在 IndexDB 中，我们可以创建多个数据库，一个数据库中创建多张表，一张表中存储多条数据——这足以 hold 住复杂的结构性数据。IndexDB 可以看做是 LocalStorage 的一个升级，当数据的复杂度和规模上升到了 LocalStorage 无法解决的程度，我们毫无疑问可以请出 IndexDB 来帮忙。  </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>浏览器缓存/存储技术的出现和发展，为我们的前端应用带来了无限的转机。近年来基于缓存/存储技术的第三方库层出不绝，此外还衍生出了 <a href="https://lavas.baidu.com/pwa" target="_blank" rel="noopener">PWA</a> 这样优秀的 Web 应用模型。可以说，现代前端应用，尤其是移动端应用，之所以可以发展到在体验上叫板 Native 的地步，主要就是仰仗缓存/存储立下的汗马功劳。    </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/28/前端性能优化原理与实践/12应用篇 2：事件的节流（throttle）与防抖（debounce）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qicainiao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qicainiao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/28/前端性能优化原理与实践/12应用篇 2：事件的节流（throttle）与防抖（debounce）/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-28T19:01:07+08:00">
                2019-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="事件的节流（throttle）与防抖（debounce）"><a href="#事件的节流（throttle）与防抖（debounce）" class="headerlink" title="事件的节流（throttle）与防抖（debounce）"></a>事件的节流（throttle）与防抖（debounce）</h1><p>上一节我们一起通过监听滚动事件，实现了各大网站喜闻乐见的懒加载效果。但我们提到，scroll 事件是一个非常容易被反复触发的事件。其实不止 scroll 事件，resize 事件、鼠标事件（比如 mousemove、mouseover 等）、键盘事件（keyup、keydown 等）都存在被频繁触发的风险。</p>
<p>频繁触发回调导致的大量计算会引发页面的抖动甚至卡顿。为了规避这种情况，我们需要一些手段来控制事件被触发的频率。就是在这样的背景下，throttle（事件节流）和 debounce（事件防抖）出现了。    </p>
<h2 id="“节流”与“防抖”的本质"><a href="#“节流”与“防抖”的本质" class="headerlink" title="“节流”与“防抖”的本质"></a>“节流”与“防抖”的本质</h2><p>这两个东西都以<strong>闭包</strong>的形式存在。    </p>
<p>它们通过对事件对应的回调函数进行包裹、以自由变量的形式缓存时间信息，最后用 setTimeout 来控制事件的触发频率。</p>
<h2 id="Throttle：-第一个人说了算"><a href="#Throttle：-第一个人说了算" class="headerlink" title="Throttle： 第一个人说了算"></a>Throttle： 第一个人说了算</h2><p>throttle 的中心思想在于：在某段时间内，不管你触发了多少次回调，我都只认第一次，并在计时结束时给予响应。   </p>
<p>先给大家讲个小故事：现在有一个旅客刚下了飞机，需要用车，于是打电话叫了该机场唯一的一辆机场大巴来接。司机开到机场，心想来都来了，多接几个人一起走吧，这样这趟才跑得值——我等个十分钟看看。于是司机一边打开了计时器，一边招呼后面的客人陆陆续续上车。在这十分钟内，后面下飞机的乘客都只能乘这一辆大巴，十分钟过去后，不管后面还有多少没挤上车的乘客，这班车都必须发走。</p>
<p>在这个故事里，“司机” 就是我们的节流阀，他控制发车的时机；“乘客”就是因为我们频繁操作事件而不断涌入的回调任务，它需要接受“司机”的安排；而“计时器”，就是我们上文提到的以自由变量形式存在的时间信息，它是“司机”决定发车的依据；最后“发车”这个动作，就对应到回调函数的执行。       </p>
<p>总结下来，所谓的“节流”，是通过在一段时间内<strong>无视后来产生的回调请求</strong>来实现的。只要一位客人叫了车，司机就会为他开启计时器，一定的时间内，后面需要乘车的客人都得排队上这一辆车，谁也无法叫到更多的车。   </p>
<p>对应到实际的交互上是一样一样的：每当用户触发了一次 scroll 事件，我们就为这个触发操作开启计时器。一段时间内，后续所有的 scroll 事件都会被当作“一辆车的乘客”——它们无法触发新的 scroll 回调。直到“一段时间”到了，第一次触发的 scroll 事件对应的回调才会执行，而“一段时间内”触发的后续的 scroll 回调都会被节流阀无视掉。</p>
<p>理解了大致的思路，我们现在一起实现一个 throttle： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn是我们需要包装的事件回调, interval是时间间隔的阈值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, interval</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// last为上一次触发回调的时间</span></span><br><span class="line">  <span class="keyword">let</span> last = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将throttle处理结果当作函数返回</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 保留调用时的this上下文</span></span><br><span class="line">      <span class="keyword">let</span> context = <span class="keyword">this</span></span><br><span class="line">      <span class="comment">// 保留调用时传入的参数</span></span><br><span class="line">      <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">      <span class="comment">// 记录本次触发回调的时间</span></span><br><span class="line">      <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值</span></span><br><span class="line">      <span class="keyword">if</span> (now - last &gt;= interval) &#123;</span><br><span class="line">      <span class="comment">// 如果时间间隔大于我们设定的时间间隔阈值，则执行回调</span></span><br><span class="line">          last = now;</span><br><span class="line">          fn.apply(context, args);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用throttle来包装scroll的回调</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'scroll'</span>, throttle(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'触发了滚动事件'</span>), <span class="number">1000</span>))</span><br></pre></td></tr></table></figure>

<h2 id="Debounce：-最后一个人说了算"><a href="#Debounce：-最后一个人说了算" class="headerlink" title="Debounce： 最后一个人说了算"></a>Debounce： 最后一个人说了算</h2><p>防抖的中心思想在于：我会等你到底。在某段时间内，不管你触发了多少次回调，我都只认最后一次。   </p>
<p>继续讲司机开车的故事。这次的司机比较有耐心。第一个乘客上车后，司机开始计时（比如说十分钟）。十分钟之内，如果又上来了一个乘客，司机会把计时器清零，重新开始等另一个十分钟（延迟了等待）。直到有这么一位乘客，从他上车开始，后续十分钟都没有新乘客上车，司机会认为确实没有人需要搭这趟车了，才会把车开走。     </p>
<p>我们对比 throttle 来理解 debounce：在throttle的逻辑里，“第一个人说了算”，它只为第一个乘客计时，时间到了就执行回调。而 debounce 认为，“最后一个人说了算”，debounce 会为每一个新乘客设定新的定时器。   </p>
<p>我们基于上面的理解，一起来写一个 debounce：   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn是我们需要包装的事件回调, delay是每次推迟执行的等待时间</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定时器</span></span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将debounce处理结果当作函数返回</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 保留调用时的this上下文</span></span><br><span class="line">    <span class="keyword">let</span> context = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 保留调用时传入的参数</span></span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次事件被触发时，都去清除之前的旧定时器</span></span><br><span class="line">    <span class="keyword">if</span>(timer) &#123;</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设立新定时器</span></span><br><span class="line">    timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      fn.apply(context, args)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用debounce来包装scroll的回调</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'scroll'</span>, debounce(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'触发了滚动事件'</span>), <span class="number">1000</span>))</span><br></pre></td></tr></table></figure>


<h2 id="用-Throttle-来优化-Debounce"><a href="#用-Throttle-来优化-Debounce" class="headerlink" title="用 Throttle 来优化 Debounce"></a>用 Throttle 来优化 Debounce</h2><p>debounce 的问题在于它“太有耐心了”。试想，如果用户的操作十分频繁——他每次都不等 debounce 设置的 delay 时间结束就进行下一次操作，于是每次 debounce 都为该用户重新生成定时器，回调函数被延迟了不计其数次。频繁的延迟会导致用户迟迟得不到响应，用户同样会产生“这个页面卡死了”的观感。    </p>
<p>为了避免弄巧成拙，我们需要借力 throttle 的思想，打造一个“有底线”的 debounce——等你可以，但我有我的原则：delay 时间内，我可以为你重新生成定时器；但只要delay的时间到了，我必须要给用户一个响应。这个 throttle 与 debounce “合体”思路，已经被很多成熟的前端库应用到了它们的加强版 throttle 函数的实现中：    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn是我们需要包装的事件回调, delay是时间间隔的阈值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// last为上一次触发回调的时间, timer是定时器</span></span><br><span class="line">  <span class="keyword">let</span> last = <span class="number">0</span>, timer = <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 将throttle处理结果当作函数返回</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="comment">// 保留调用时的this上下文</span></span><br><span class="line">    <span class="keyword">let</span> context = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 保留调用时传入的参数</span></span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="comment">// 记录本次触发回调的时间</span></span><br><span class="line">    <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值</span></span><br><span class="line">    <span class="keyword">if</span> (now - last &lt; delay) &#123;</span><br><span class="line">    <span class="comment">// 如果时间间隔小于我们设定的时间间隔阈值，则为本次触发操作设立一个新的定时器</span></span><br><span class="line">       clearTimeout(timer)</span><br><span class="line">       timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          last = now</span><br><span class="line">          fn.apply(context, args)</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果时间间隔超出了我们设定的时间间隔阈值，那就不等了，无论如何要反馈给用户一次响应</span></span><br><span class="line">        last = now</span><br><span class="line">        fn.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用新的throttle包装scroll的回调</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'scroll'</span>, throttle(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'触发了滚动事件'</span>), <span class="number">1000</span>))</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>throttle 和 debounce 不仅是我们日常开发中的常用优质代码片段，更是前端面试中不可不知的高频考点。“看懂了代码”、“理解了过程”在本节都是不够的，重要的是把它写到自己的项目里去，亲自体验一把节流和防抖带来的性能提升。   </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/28/前端性能优化原理与实践/14前方的路：希望以此为你的起点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qicainiao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qicainiao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/28/前端性能优化原理与实践/14前方的路：希望以此为你的起点/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-28T19:01:07+08:00">
                2019-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前方的路：希望成为你的起点"><a href="#前方的路：希望成为你的起点" class="headerlink" title="前方的路：希望成为你的起点"></a>前方的路：希望成为你的起点</h1><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>首先要谢谢每一位读到最后一章的同学。这是我的第一本小册，也是我第一次撰写对外开放的知识内容，谢谢大家选择了这本小册，选择了我这个作者。    </p>
<h2 id="未完成的故事"><a href="#未完成的故事" class="headerlink" title="未完成的故事"></a>未完成的故事</h2><p>对笔者来说，撰写小册的两个月，是挑战重重的两个月。在这个过程中，笔者时时刻刻都在与“程序员”和“技术作者”这两个角色较劲。前者要求我锱铢必较、求深求全，后者则需要我在小册内容的深度、广度与可读性之间作出权衡。正是因为有了这一番又一番的权衡，它才终于被打磨成了一本篇幅短小、卖相可爱的“小册”，而非一本庞大的、令人望而生畏的“手册”。   </p>
<p>但也是因为如此，小册里多出了一些“未完成的故事”。比如网络优化这部分，我想可能会有同学兴致勃勃地想听一听 DNS 的预解析或者 TCP 协议的负载均衡；再比如资源加载这一块，为什么说了 async  和 defer，却没有提 preload 和 prefetch 呢？又或者比较追逐“潮流”的同学，心心念念的是 Service Worker 和 Web Worker 的应用方案；甚至所在团队性能这块还没做起来的同学，希望我可以提供能够耦合进业务的性能监测方案，等等（这些都是非常实际的阅读需求）。    </p>
<p>但正如我开篇所说的，我的初心并非是为大家提供一本面面俱到的“手册”。前端性能优化的知识点零碎、不成体系，这是它学习的痛点，也是小册想要解决的问题。有许多同样精彩的性能知识，我们可以针对它做技术方案测试、可以为它开研讨会，但它并不适合出现在小册的写作大纲里、以短文的形式呈现。我希望呈现给大家的内容，是前后相连，自成体系的“一串”知识。是大家在学习、工作之余，在等公交、搭地铁的间隙，在碎片化的时间里，仍然能够轻松阅读并理解的友好内容。</p>
<h2 id="前方的路"><a href="#前方的路" class="headerlink" title="前方的路"></a>前方的路</h2><p>小册之愿，是希望成为大家性能优化这条路上的起点。   </p>
<p>相对于模式成熟、方案完善的服务端性能优化来说，前端性能优化整体的起步是比较晚的。但在当今的大环境下，它又是极其重要的一个工作。我们是离用户最近的工程师，需要直接对用户的体验负责。因此，我们需要做的努力还有太多太多。    </p>
<p>既然已经读到了最后一章，我想大家应该都收获了一张属于自己的前端性能优化的核心知识“索引表”——我希望它能成为大家的起点，成为各位今后拓展相关技能的素材。当下前端世界里，提起技术，许多初学者第一反应仍然是学框架、学工具。框架和工具固然重要，但一个合格的前端工程师，还应该具有抽象思维的能力和技术攻关的实力——这两点，都可以在性能优化的学习和实践过程中得到磨炼和凸显。</p>
<p>在庞大的前端性能知识体系面前，一本单薄的小册是远远不够的。接下来大家要做的，就是实践、实践、再实践！反复地阅读文字、一味地深究理论是无法使我们的技能变“厚”的，最好的办法就是去做，去用，在用的过程中发现问题、解决问题、拓展问题——那些“未完成的故事”，一定会在这个过程中被你书写圆满。    </p>
<p>把这张“索引表”装进行囊，继续征战你的前端性能优化之旅吧！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/28/前端性能优化原理与实践/9渲染篇 4：千方百计——Event Loop 与异步更新策略/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qicainiao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qicainiao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/28/前端性能优化原理与实践/9渲染篇 4：千方百计——Event Loop 与异步更新策略/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-28T19:01:07+08:00">
                2019-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="千方百计——Event-Loop-与异步更新策略"><a href="#千方百计——Event-Loop-与异步更新策略" class="headerlink" title="千方百计——Event Loop 与异步更新策略"></a>千方百计——Event Loop 与异步更新策略</h1><p>Vue 和 React 都实现了异步更新策略。虽然实现的方式不尽相同，但都达到了减少 DOM 操作、避免过度渲染的目的。通过研究框架的运行机制，其设计思路将深化我们对 DOM 优化的理解，其实现手法将拓宽我们对 DOM 实践的认知。   </p>
<p>本节我们将基于 Event Loop 机制，对 Vue 的异步更新策略作探讨。   </p>
<h2 id="前置知识：Event-Loop-中的“渲染时机”"><a href="#前置知识：Event-Loop-中的“渲染时机”" class="headerlink" title="前置知识：Event Loop 中的“渲染时机”"></a>前置知识：Event Loop 中的“渲染时机”</h2><p>搞懂 Event Loop，是理解 Vue 对 DOM 操作优化的第一步。</p>
<h3 id="Micro-Task-与-Macro-Task"><a href="#Micro-Task-与-Macro-Task" class="headerlink" title="Micro-Task 与 Macro-Task"></a>Micro-Task 与 Macro-Task</h3><p>事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。   </p>
<p>常见的 macro-task 比如： setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作、UI 渲染等。<br>常见的 micro-task 比如: process.nextTick、Promise、MutationObserver 等。   </p>
<h3 id="Event-Loop-过程解析"><a href="#Event-Loop-过程解析" class="headerlink" title="Event Loop 过程解析"></a>Event Loop 过程解析</h3><p>基于对 micro 和 macro 的认知，我们来走一遍完整的事件循环过程。  </p>
<p>一个完整的 Event Loop 过程，可以概括为以下阶段： </p>
<ul>
<li><p>初始状态：调用栈空。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。</p>
</li>
<li><p>全局上下文（script 标签）被推入调用栈，同步代码执行。在执行的过程中，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，<strong>这个过程本质上是队列的 macro-task 的执行和出队的过程</strong>。</p>
</li>
<li><p>上一步我们出队的是一个 macro-task，这一步我们处理的是 micro-task。但需要注意的是：当 macro-task 出队时，任务是<strong>一个一个</strong>执行的；而 micro-task 出队时，任务是<strong>一队一队</strong>执行的（如下图所示）。因此，我们处理 micro 队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。</p>
</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/1/1662fc9d8bf609a6?w=480&h=410&f=png&s=8715" alt>   </p>
<ul>
<li><p><strong>执行渲染操作，更新界面</strong>（敲黑板划重点）。</p>
</li>
<li><p>检查是否存在 Web worker 任务，如果有，则对其进行处理 。  </p>
</li>
</ul>
<p>（上述过程循环往复，直到两个队列都清空）      </p>
<p>我们总结一下，每一次循环都是一个这样的过程：    </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/1/1662ff57ebe7a73f?w=857&h=243&f=png&s=28272" alt></p>
<h3 id="渲染的时机"><a href="#渲染的时机" class="headerlink" title="渲染的时机"></a>渲染的时机</h3><p>大家现在思考一个这样的问题：假如我想要在异步任务里进行DOM更新，我该把它包装成 micro 还是 macro 呢？ </p>
<p>我们先假设它是一个 macro 任务，比如我在 script 脚本中用 setTimeout 来处理它： </p>
<pre><code class="javascript"><span class="comment">// task是一个用于修改DOM的回调</span>
setTimeout(task, <span class="number">0</span>)</code></pre>
<p>现在 task 被推入的 macro 队列。但因为 script 脚本本身是一个 macro 任务，所以本次执行完 script 脚本之后，下一个步骤就要去处理 micro 队列了，再往下就去执行了一次 render，对不对？ </p>
<p>但本次render我的目标task其实并没有执行，想要修改的DOM也没有修改，因此这一次的render其实是一次无效的render。    </p>
<p>macro 不 ok，我们转向 micro 试试看。我用 Promise 来把 task 包装成是一个 micro 任务： </p>
<pre><code class="javascript"><span class="built_in">Promise</span>.resolve().then(task)</code></pre>
<p>那么我们结束了对 script 脚本的执行，是不是紧接着就去处理 micro-task 队列了？micro-task 处理完，DOM 修改好了，紧接着就可以走 render 流程了——不需要再消耗多余的一次渲染，不需要再等待一轮事件循环，直接为用户呈现最即时的更新结果。    </p>
<p>因此，我们更新 DOM 的时间点，应该尽可能靠近渲染的时机。<strong>当我们需要在异步任务中实现 DOM 修改时，把它包装成 micro 任务是相对明智的选择</strong>。    </p>
<h2 id="生产实践：异步更新策略——以-Vue-为例"><a href="#生产实践：异步更新策略——以-Vue-为例" class="headerlink" title="生产实践：异步更新策略——以 Vue 为例"></a>生产实践：异步更新策略——以 Vue 为例</h2><p>什么是异步更新？</p>
<p>当我们使用 Vue 或 React 提供的接口去更新数据时，这个更新并不会立即生效，而是会被推入到一个队列里。待到适当的时机，队列中的更新任务会被<strong>批量触发</strong>。这就是异步更新。 </p>
<p>异步更新可以帮助我们避免过度渲染，是我们上节提到的“让 JS 为 DOM 分压”的典范之一。   </p>
<h3 id="异步更新的优越性"><a href="#异步更新的优越性" class="headerlink" title="异步更新的优越性"></a>异步更新的优越性</h3><p>异步更新的特性在于它<strong>只看结果</strong>，因此渲染引擎<strong>不需要为过程买单</strong>。    </p>
<p>最典型的例子，比如有时我们会遇到这样的情况： </p>
<pre><code class="javascript"><span class="comment">// 任务一</span>
<span class="keyword">this</span>.content = <span class="string">'第一次测试'</span>
<span class="comment">// 任务二</span>
<span class="keyword">this</span>.content = <span class="string">'第二次测试'</span>
<span class="comment">// 任务三</span>
<span class="keyword">this</span>.content = <span class="string">'第三次测试'</span></code></pre>
<p>我们在三个更新任务中对同一个状态修改了三次，如果我们采取传统的同步更新策略，那么就要操作三次 DOM。但本质上需要呈现给用户的目标内容其实只是第三次的结果，也就是说只有第三次的操作是有意义的——我们白白浪费了两次计算。   </p>
<p>但如果我们把这三个任务塞进异步更新队列里，它们会先在 JS 的层面上被<strong>批量执行完毕</strong>。当流程走到渲染这一步时，它仅仅需要针对有意义的计算结果操作一次 DOM——这就是异步更新的妙处。   </p>
<h3 id="Vue状态更新手法：nextTick"><a href="#Vue状态更新手法：nextTick" class="headerlink" title="Vue状态更新手法：nextTick"></a>Vue状态更新手法：nextTick</h3><p>Vue 每次想要更新一个状态的时候，会先把它这个更新操作给包装成一个异步操作派发出去。这件事情，在源码中是由一个叫做 nextTick 的函数来完成的：   </p>
<pre><code class="javascript"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span> (<span class="params">cb?: Function, ctx?: Object</span>) </span>{
  <span class="keyword">let</span> _resolve
  callbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> {
    <span class="keyword">if</span> (cb) {
      <span class="keyword">try</span> {
        cb.call(ctx)
      } <span class="keyword">catch</span> (e) {
        handleError(e, ctx, <span class="string">'nextTick'</span>)
      }
    } <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) {
      _resolve(ctx)
    }
  })
  <span class="comment">// 检查上一个异步任务队列（即名为callbacks的任务数组）是否派发和执行完毕了。pending此处相当于一个锁</span>
  <span class="keyword">if</span> (!pending) {
    <span class="comment">// 若上一个异步任务队列已经执行完毕，则将pending设定为true（把锁锁上）</span>
    pending = <span class="literal">true</span>
    <span class="comment">// 是否要求一定要派发为macro任务</span>
    <span class="keyword">if</span> (useMacroTask) {
      macroTimerFunc()
    } <span class="keyword">else</span> {
      <span class="comment">// 如果不说明一定要macro 你们就全都是micro</span>
      microTimerFunc()
    }
  }
  <span class="comment">// $flow-disable-line</span>
  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span>) {
    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> {
      _resolve = resolve
    })
  }
}</code></pre>
<p>我们看到，Vue 的异步任务默认情况下都是用 Promise 来包装的，也就是是说它们都是 micro-task。这一点和我们“前置知识”中的渲染时机的分析不谋而合。</p>
<p>为了带大家熟悉一下常见的 macro 和 micro 派发方式、加深对 Event Loop 的理解，我们继续细化解析一下 macroTimeFunc() 和 microTimeFunc() 两个方法。</p>
<p>macroTimeFunc() 是这么实现的：  </p>
<pre><code class="javascript"><span class="comment">// macro首选setImmediate 这个兼容性最差</span>
<span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">'undefined'</span> &amp;&amp; isNative(setImmediate)) {
  macroTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> {
    setImmediate(flushCallbacks)
  }
} <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> MessageChannel !== <span class="string">'undefined'</span> &amp;&amp; (
    isNative(MessageChannel) ||
    <span class="comment">// PhantomJS</span>
    MessageChannel.toString() === <span class="string">'[object MessageChannelConstructor]'</span>
  )) {
  <span class="keyword">const</span> channel = <span class="keyword">new</span> MessageChannel()
  <span class="keyword">const</span> port = channel.port2
  channel.port1.onmessage = flushCallbacks
  macroTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> {
    port.postMessage(<span class="number">1</span>)
  }
} <span class="keyword">else</span> {
  <span class="comment">// 兼容性最好的派发方式是setTimeout</span>
  macroTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> {
    setTimeout(flushCallbacks, <span class="number">0</span>)
  }
}</code></pre>
<p>microTimeFunc() 是这么实现的： </p>
<pre><code class="javascript"><span class="comment">// 简单粗暴 不是ios全都给我去Promise 如果不兼容promise 那么你只能将就一下变成macro了</span>
<span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) {
  <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve()
  microTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> {
    p.then(flushCallbacks)
    <span class="comment">// in problematic UIWebViews, Promise.then doesn't completely break, but</span>
    <span class="comment">// it can get stuck in a weird state where callbacks are pushed into the</span>
    <span class="comment">// microtask queue but the queue isn't being flushed, until the browser</span>
    <span class="comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span>
    <span class="comment">// "force" the microtask queue to be flushed by adding an empty timer.</span>
    <span class="keyword">if</span> (isIOS) setTimeout(noop)
  }
} <span class="keyword">else</span> {
  <span class="comment">// 如果无法派发micro，就退而求其次派发为macro</span>
  microTimerFunc = macroTimerFunc
}</code></pre>
<p>我们注意到，无论是派发 macro 任务还是派发 micro 任务，派发的任务对象都是一个叫做 flushCallbacks 的东西，这个东西做了什么呢？  </p>
<p>flushCallbacks 源码如下：  </p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">flushCallbacks</span> (<span class="params"></span>) </span>{
  pending = <span class="literal">false</span>
  <span class="comment">// callbacks在nextick中出现过 它是任务数组（队列）</span>
  <span class="keyword">const</span> copies = callbacks.slice(<span class="number">0</span>)
  callbacks.length = <span class="number">0</span>
  <span class="comment">// 将callbacks中的任务逐个取出执行</span>
  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.length; i++) {
    copies[i]()
  }
}</code></pre>
<p>现在我们理清楚了：Vue 中每产生一个状态更新任务，它就会被塞进一个叫 callbacks 的数组（此处是任务队列的实现形式）中。这个任务队列在被丢进 micro 或 macro 队列之前，会先去检查当前是否有异步更新任务正在执行（即检查 pending 锁）。如果确认 pending 锁是开着的（false），就把它设置为锁上（true），然后对当前 callbacks 数组的任务进行派发（丢进 micro 或 macro 队列）和执行。设置 pending 锁的意义在于保证状态更新任务的有序进行，避免发生混乱。        </p>
<p>本小节我们从性能优化的角度出发，通过解析Vue源码，对异步更新这一高效的 DOM 优化手段有了感性的认知。同时帮助大家进一步熟悉了 micro 与 macro 在生产中的应用，加深了对 Event Loop 的理解。事实上，Vue 源码中还有许多值得称道的生产实践，其设计模式与编码细节都值得我们去细细品味。对这个话题感兴趣的同学，课后不妨移步 <a href="https://juejin.im/book/5a36661851882538e2259c0f" target="_blank" rel="noopener">Vue运行机制解析</a> 进行探索。   </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，我们的 DOM 优化之路才走完了一半。</p>
<p>以上我们都在讨论“如何减少 DOM 操作”的话题。这个话题比较宏观——DOM 操作也分很多种，它们带来的变化各不相同。有的操作只触发重绘，这时我们的性能损耗就小一些；有的操作会触发回流，这时我们更“肉疼”一些。那么如何理解回流与重绘，如何借助这些理解去提升页面渲染效率呢？    </p>
<p>结束了 JS 的征程，我们下面就走进 CSS 的世界一窥究竟。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/28/前端性能优化原理与实践/6渲染篇 1：服务端渲染的探索与实践/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qicainiao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qicainiao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/28/前端性能优化原理与实践/6渲染篇 1：服务端渲染的探索与实践/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-28T19:01:07+08:00">
                2019-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="服务端渲染的探索与实践"><a href="#服务端渲染的探索与实践" class="headerlink" title="服务端渲染的探索与实践"></a>服务端渲染的探索与实践</h1><p>服务端渲染（SSR）近两年炒得很火热，相信各位同学对这个名词多少有所耳闻。本节我们将围绕“是什么”（服务端渲染的运行机制）、“为什么”（服务端渲染解决了什么性能问题  ）、“怎么做”（服务端渲染的应用实例与使用场景）这三个点，对服务端渲染进行探索。</p>
<p>服务端渲染是一个相对的概念，它的对立面是“客户端渲染”。在运行机制解析这部分，我们会借力客户端渲染的概念，来帮大家理解服务端渲染的工作方式。基于对工作方式的了解，再去深挖它的原理与优势。</p>
<p>任何知识点都不是“一座孤岛”，服务端渲染的实践往往与当下流行的前端技术（譬如 Vue，React，Redux 等）紧密结合。本节下半场将以 React 和 Vue 下的服务端渲染实现为例，为大家呈现一个完整的 SSR 实现过程。</p>
<h2 id="服务端渲染的运行机制"><a href="#服务端渲染的运行机制" class="headerlink" title="服务端渲染的运行机制"></a>服务端渲染的运行机制</h2><p>相对于服务端渲染，同学们普遍对客户端渲染接受度更高一些，所以我们先从大家喜闻乐见的客户端渲染说起。</p>
<h3 id="客户端渲染"><a href="#客户端渲染" class="headerlink" title="客户端渲染"></a>客户端渲染</h3><p>客户端渲染模式下，服务端会把渲染需要的静态文件发送给客户端，客户端加载过来之后，自己在浏览器里跑一遍 JS，根据 JS 的运行结果，生成相应的 DOM。这种特性使得客户端渲染的源代码总是特别简洁，往往是这个德行：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>我是客户端渲染的页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'root'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'index.js'</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>根节点下到底是什么内容呢？你不知道，我不知道，只有浏览器把 index.js 跑过一遍后才知道，这就是典型的客户端渲染。</p>
<p><strong>页面上呈现的内容，你在 html 源文件里里找不到</strong>——这正是它的特点。   </p>
<h3 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h3><p>服务端渲染的模式下，当用户第一次请求页面时，由服务器把需要的组件或页面渲染成 HTML 字符串，然后把它返回给客户端。客户端拿到手的，是可以直接渲染然后呈现给用户的 HTML 内容，不需要为了生成 DOM 内容自己再去跑一遍 JS 代码。 </p>
<p>使用服务端渲染的网站，可以说是“所见即所得”，<strong>页面上呈现的内容，我们在 html 源文件里也能找到</strong>。</p>
<p>比如知乎就是典型的服务端渲染案例：    </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/26/166162c1cbad2c64?w=2736&h=582&f=png&s=351372" alt> </p>
<p>zhihu&#46;com 返回的 HTML 文件已经是可以直接进行渲染的内容了。</p>
<h2 id="服务端渲染解决了什么性能问题"><a href="#服务端渲染解决了什么性能问题" class="headerlink" title="服务端渲染解决了什么性能问题"></a>服务端渲染解决了什么性能问题</h2><p>事实上，很多网站是出于效益的考虑才启用服务端渲染，性能倒是在其次。 </p>
<p>假设 A 网站页面中有一个关键字叫“前端性能优化”，这个关键字是 JS 代码跑过一遍后添加到 HTML 页面中的。那么客户端渲染模式下，我们在搜索引擎搜索这个关键字，是找不到 A 网站的——搜索引擎只会查找现成的内容，不会帮你跑 JS 代码。A 网站的运营方见此情形，感到很头大：搜索引擎搜不出来，用户找不到我们，谁还会用我的网站呢？为了把“现成的内容”拿给搜索引擎看，A 网站不得不启用服务端渲染。   </p>
<p>但性能在其次，不代表性能不重要。服务端渲染解决了一个非常关键的性能问题——首屏加载速度过慢。在客户端渲染模式下，我们除了加载 HTML，还要等渲染所需的这部分 JS 加载完，之后还得把这部分 JS 在浏览器上再跑一遍。这一切都是发生在用户点击了我们的链接之后的事情，在这个过程结束之前，用户始终见不到我们网页的庐山真面目，也就是说用户一直在等！相比之下，服务端渲染模式下，服务器给到客户端的已经是一个直接可以拿来呈现给用户的网页，中间环节早在服务端就帮我们做掉了，用户岂不“美滋滋”？   </p>
<h2 id="服务端渲染的应用实例"><a href="#服务端渲染的应用实例" class="headerlink" title="服务端渲染的应用实例"></a>服务端渲染的应用实例</h2><p>下面我们先来看一下在一个 React 项目里，服务端渲染是怎么实现的。本例中，我们使用 Express 搭建后端服务。</p>
<p>项目中有一个叫做 VDom 的 React 组件，它的内容如下。 </p>
<p>VDom.js:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> VDom = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>我是一个被渲染为真实DOM的虚拟DOM<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> VDom</span><br><span class="line"><span class="string">``</span><span class="string">`   </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在服务端的入口文件中，我引入这个组件，对它进行渲染：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">'express'</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; renderToString &#125; <span class="keyword">from</span> <span class="string">'react-dom/server'</span></span><br><span class="line"><span class="keyword">import</span> VDom <span class="keyword">from</span> <span class="string">'./VDom'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个express应用</span></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"><span class="comment">// renderToString 是把虚拟DOM转化为真实DOM的关键方法</span></span><br><span class="line"><span class="keyword">const</span> RDom = renderToString(<span class="xml"><span class="tag">&lt;<span class="name">VDom</span> /&gt;</span>)</span></span><br><span class="line"><span class="xml">// 编写HTML模板，插入转化后的真实DOM内容</span></span><br><span class="line"><span class="xml">const Page = `</span></span><br><span class="line">            &lt;html&gt;</span><br><span class="line">              &lt;head&gt;</span><br><span class="line">                &lt;title&gt;test&lt;/title&gt;</span><br><span class="line">              &lt;/head&gt;</span><br><span class="line">              &lt;body&gt;</span><br><span class="line">                &lt;span&gt;服务端渲染出了真实DOM:  &lt;/span&gt;</span><br><span class="line">                $&#123;RDom&#125;</span><br><span class="line">              &lt;/body&gt;</span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml">            `</span></span><br><span class="line"><span class="xml">            </span></span><br><span class="line"><span class="xml">// 配置HTML内容对应的路由</span></span><br><span class="line"><span class="xml">app.get('/index', function(req, res) &#123;</span></span><br><span class="line"><span class="xml">  res.send(Page)</span></span><br><span class="line"><span class="xml">&#125;)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// 配置端口号</span></span><br><span class="line"><span class="xml">const server = app.listen(8000)</span></span><br><span class="line"><span class="xml">```  </span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">根据我们的路由配置，当我访问 http://localhost:8000/index 时，就可以呈现出服务端渲染的结果了：    </span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">![](https://user-gold-cdn.xitu.io/2018/9/26/16615e831fa4c113?w=1502&amp;h=408&amp;f=png&amp;s=129026)  </span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">我们可以看到，VDom 组件已经被 renderToString 转化为了一个内容为```<span class="tag">&lt;<span class="name">div</span> <span class="attr">data-reactroot</span>=<span class="string">""</span>&gt;</span>我是一个被渲染为真实DOM的虚拟DOM<span class="tag">&lt;/<span class="name">div</span>&gt;</span>```的字符串，这个字符串被插入 HTML 代码，成为了真实 DOM 树的一部分。  </span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">那么 Vue 是如何实现服务端渲染的呢？</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">其实是一个套路，我这里基于 [Vue SSR 指南](https://ssr.vuejs.org/zh/#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93-ssr-%EF%BC%9F) 中官方给出的例子为大家讲解 Vue 中的实现思路（思路见注释）。</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">该示例直接将 Vue 实例整合进了服务端的入口文件中：  </span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">```javascript</span></span><br><span class="line"><span class="xml">const Vue = require('vue')</span></span><br><span class="line"><span class="xml">// 创建一个express应用</span></span><br><span class="line"><span class="xml">const server = require('express')()</span></span><br><span class="line"><span class="xml">// 提取出renderer实例</span></span><br><span class="line"><span class="xml">const renderer = require('vue-server-renderer').createRenderer()</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">server.get('*', (req, res) =&gt; &#123;</span></span><br><span class="line"><span class="xml">  // 编写Vue实例（虚拟DOM节点）</span></span><br><span class="line"><span class="xml">  const app = new Vue(&#123;</span></span><br><span class="line"><span class="xml">    data: &#123;</span></span><br><span class="line"><span class="xml">      url: req.url</span></span><br><span class="line"><span class="xml">    &#125;,</span></span><br><span class="line"><span class="xml">    // 编写模板HTML的内容</span></span><br><span class="line"><span class="xml">    template: `<span class="tag">&lt;<span class="name">div</span>&gt;</span>访问的 URL 是： &#123;&#123; url &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>`</span></span><br><span class="line"><span class="xml">  &#125;)</span></span><br><span class="line"><span class="xml">    </span></span><br><span class="line"><span class="xml">  // renderToString 是把Vue实例转化为真实DOM的关键方法</span></span><br><span class="line"><span class="xml">  renderer.renderToString(app, (err, html) =&gt; &#123;</span></span><br><span class="line"><span class="xml">    if (err) &#123;</span></span><br><span class="line"><span class="xml">      res.status(500).end('Internal Server Error')</span></span><br><span class="line"><span class="xml">      return</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    // 把渲染出来的真实DOM字符串插入HTML模板中</span></span><br><span class="line"><span class="xml">    res.end(`</span></span><br><span class="line"><span class="xml">      <span class="meta">&lt;!DOCTYPE html&gt;</span></span></span><br><span class="line">      &lt;html lang="en"&gt;</span><br><span class="line">        &lt;head&gt;&lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">        &lt;body&gt;$&#123;html&#125;&lt;/body&gt;</span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml">    `)</span></span><br><span class="line"><span class="xml">  &#125;)</span></span><br><span class="line"><span class="xml">&#125;)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">server.listen(8080)</span></span><br></pre></td></tr></table></figure>

<p>大家对比一下 React 项目中的注释内容，是不是发现这两段代码从本质上来说区别不大呢？      </p>
<p>以上两个小🌰，为大家演示了基本的服务端渲染实现流程。</p>
<p>实际项目比这些复杂很多，但万变不离其宗。强调的只有两点：一是这个 renderToString() 方法；二是把转化结果“塞”进模板里的这一步。这两个操作是服务端渲染的灵魂操作。在虚拟 DOM“横行”的当下，服务端渲染不再是早年 JSP 里简单粗暴的字符串拼接过程，它还要求这一端要具备将虚拟 DOM 转化为真实 DOM 的能力。与其说是“把 JS 在服务器上先跑一遍”，不如说是“把 Vue、React 等框架代码先在 Node 上跑一遍”。   </p>
<h2 id="服务端渲染的应用场景"><a href="#服务端渲染的应用场景" class="headerlink" title="服务端渲染的应用场景"></a>服务端渲染的应用场景</h2><p>打眼一看，这个服务端渲染给浏览器省了这么多事儿，性能肯定是质的飞跃啊！喜闻乐见！但是大家打开自己经常访问的那些网页看一看，会发现仍然有许多网站压根儿不用服务端渲染——看来这个东西也不是万能的。    </p>
<p>根据我们前面的描述，不难看出，服务端渲染本质上是<strong>本该浏览器做的事情，分担给服务器去做</strong>。这样当资源抵达浏览器时，它呈现的速度就快了。乍一看好像很合理：浏览器性能毕竟有限，服务器多牛逼！能者多劳，就该让服务器多干点活！ </p>
<p>但仔细想想，在这个网民遍地的时代，几乎有多少个用户就有多少台浏览器。用户拥有的浏览器总量多到数不清，那么一个公司的服务器又有多少台呢？我们把这么多台浏览器的渲染压力集中起来，分散给相比之下数量并不多的服务器，服务器肯定是承受不住的。 </p>
<p>这样分析下来，服务端渲染也并非万全之策。在实践中，我一般会建议大家先忘记服务端渲染这个事情——服务器稀少而宝贵，但首屏渲染体验和 SEO 的优化方案却很多——我们最好先把能用的低成本“大招”都用完。除非网页对性能要求太高了，以至于所有的招式都用完了，性能表现还是不尽人意，这时候我们就可以考虑向老板多申请几台服务器，把服务端渲染搞起来了~</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/28/前端性能优化原理与实践/8渲染篇 3：对症下药——DOM 优化原理与基本实践/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qicainiao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qicainiao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/28/前端性能优化原理与实践/8渲染篇 3：对症下药——DOM 优化原理与基本实践/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-28T19:01:07+08:00">
                2019-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="对症下药——-DOM-优化原理与基本实践"><a href="#对症下药——-DOM-优化原理与基本实践" class="headerlink" title="对症下药—— DOM 优化原理与基本实践"></a>对症下药—— DOM 优化原理与基本实践</h1><p>从本节开始，我们要关心的两大核心问题就是：“DOM 为什么这么慢”以及“如何使 DOM 变快”。    </p>
<p>后者是一个比“生存还是毁灭”更加经典的问题。不仅我们为它“肝肠寸断”，许多优秀前端框架的作者大大们也曾为其绞尽脑汁。这一点可喜可贺——研究的人越多，产出优秀实践的概率就越大。因此在本章的方法论环节，我们不仅会根据 DOM 特性及渲染原理为大家讲解基本的优化思路，还会涉及到一部分生产实践。     </p>
<p>循着这个思路，我们把 DOM 优化这块划分为三个小专题：“DOM 优化思路”、“异步更新策略”及“回流与重绘”。本节对应第一个小专题。三个小专题休戚与共、你侬我侬，在思路上相互依赖、一脉相承，因此此处<strong>严格禁止任何姿势的跳读行为</strong>。</p>
<p>考虑到本节内容与上一节有着密不可分的关系，因此<strong>强烈不建议没有读完上一节的同学直接跳读本节</strong>。     </p>
<h2 id="望闻问切：DOM-为什么这么慢"><a href="#望闻问切：DOM-为什么这么慢" class="headerlink" title="望闻问切：DOM 为什么这么慢"></a>望闻问切：DOM 为什么这么慢</h2><h3 id="因为收了“过路费”"><a href="#因为收了“过路费”" class="headerlink" title="因为收了“过路费”"></a>因为收了“过路费”</h3><blockquote>
<p>把 DOM 和 JavaScript 各自想象成一个岛屿，它们之间用收费桥梁连接。——《高性能 JavaScript》</p>
</blockquote>
<p>JS 是很快的，在 JS 中修改 DOM 对象也是很快的。在JS的世界里，一切是简单的、迅速的。但 DOM 操作并非 JS 一个人的独舞，而是两个模块之间的协作。    </p>
<p>上一节我们提到，JS 引擎和渲染引擎（浏览器内核）是独立实现的。当我们用 JS 去操作 DOM 时，本质上是 JS 引擎和渲染引擎之间进行了“跨界交流”。这个“跨界交流”的实现并不简单，它依赖了桥接接口作为“桥梁”（如下图）。   </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/29/166254bce949ca58?w=618&h=242&f=png&s=51738" alt></p>
<p>过“桥”要收费——这个开销本身就是不可忽略的。我们每操作一次 DOM（不管是为了修改还是仅仅为了访问其值），都要过一次“桥”。过“桥”的次数一多，就会产生比较明显的性能问题。因此“减少 DOM 操作”的建议，并非空穴来风。    </p>
<h3 id="对-DOM-的修改引发样式的更迭"><a href="#对-DOM-的修改引发样式的更迭" class="headerlink" title="对 DOM 的修改引发样式的更迭"></a>对 DOM 的修改引发样式的更迭</h3><p>过桥很慢，到了桥对岸，我们的更改操作带来的结果也很慢。  </p>
<p>很多时候，我们对 DOM 的操作都不会局限于访问，而是为了修改它。当我们对 DOM 的修改会引发它外观（样式）上的改变时，就会触发<strong>回流</strong>或<strong>重绘</strong>。   </p>
<p>这个过程本质上还是因为我们对 DOM 的修改触发了渲染树（Render Tree）的变化所导致的：    </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/29/1662558836a66620?w=644&h=321&f=png&s=27095" alt></p>
<ul>
<li><p>回流：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。   </p>
</li>
<li><p>重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。这个过程叫做重绘。   </p>
</li>
</ul>
<p>由此我们可以看出，<strong>重绘不一定导致回流，回流一定会导致重绘</strong>。硬要比较的话，回流比重绘做的事情更多，带来的开销也更大。但这两个说到底都是吃性能的，所以都不是什么善茬。我们在开发中，要从代码层面出发，尽可能把回流和重绘的次数最小化。  </p>
<h2 id="药到病除：给你的-DOM-“提提速”"><a href="#药到病除：给你的-DOM-“提提速”" class="headerlink" title="药到病除：给你的 DOM “提提速”"></a>药到病除：给你的 DOM “提提速”</h2><p>知道了 DOM 慢的原因，我们就可以对症下药了。</p>
<h3 id="减少-DOM-操作：少交“过路费”、避免过度渲染"><a href="#减少-DOM-操作：少交“过路费”、避免过度渲染" class="headerlink" title="减少 DOM 操作：少交“过路费”、避免过度渲染"></a>减少 DOM 操作：少交“过路费”、避免过度渲染</h3><p>我们来看这样一个🌰，HTML 内容如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>DOM操作测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">此时我有一个假需求——我想往 container 元素里写 10000 句一样的话。如果我这么做：</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">for(var count=0;count<span class="tag">&lt;<span class="name">10000;count++)&#123;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">document.getElementById</span>('<span class="attr">container</span>')<span class="attr">.innerHTML</span>+=<span class="string">'&lt;span&gt;我是一个小测试&lt;/span&gt;'</span></span></span><br><span class="line"><span class="tag">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这段代码有两个明显的可优化点。</p>
<p>第一点，<strong>过路费交太多了</strong>。我们每一次循环都调用 DOM 接口重新获取了一次 container 元素，相当于每次循环都交了一次过路费。前后交了 10000 次过路费，但其中 9999 次过路费都可以用<strong>缓存变量</strong>的方式节省下来：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只获取一次container</span></span><br><span class="line"><span class="keyword">let</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> count=<span class="number">0</span>;count&lt;<span class="number">10000</span>;count++)&#123; </span><br><span class="line">  container.innerHTML += <span class="string">'&lt;span&gt;我是一个小测试&lt;/span&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二点，<strong>不必要的 DOM 更改太多了</strong>。我们的 10000 次循环里，修改了 10000 次 DOM 树。我们前面说过，对 DOM 的修改会引发渲染树的改变、进而去走一个（可能的）回流或重绘的过程，而这个过程的开销是很“贵”的。这么贵的操作，我们竟然重复执行了 N 多次！其实我们可以通过<strong>就事论事</strong>的方式节省下来不必要的渲染：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line"><span class="keyword">let</span> content = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> count=<span class="number">0</span>;count&lt;<span class="number">10000</span>;count++)&#123; </span><br><span class="line">  <span class="comment">// 先对内容进行操作</span></span><br><span class="line">  content += <span class="string">'&lt;span&gt;我是一个小测试&lt;/span&gt;'</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 内容处理好了,最后再触发DOM的更改</span></span><br><span class="line">container.innerHTML = content</span><br></pre></td></tr></table></figure>

<p>所谓“就事论事”，就像大家所看到的：JS 层面的事情，JS 自己去处理，处理好了，再来找 DOM 打报告。      </p>
<p>事实上，考虑JS 的运行速度，比 DOM 快得多这个特性。我们减少 DOM 操作的核心思路，就是<strong>让 JS 去给 DOM 分压</strong>。         </p>
<p>这个思路，在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment" target="_blank" rel="noopener">DOM Fragment</a> 中体现得淋漓尽致。   </p>
<blockquote>
<p>DocumentFragment 接口表示一个没有父级文件的最小文档对象。它被当做一个轻量版的 Document 使用，用于存储已排好版的或尚未打理好格式的XML片段。因为 DocumentFragment 不是真实 DOM 树的一部分，它的变化不会引起 DOM 树的重新渲染的操作（reflow），且不会导致性能等问题。 </p>
</blockquote>
<p>在我们上面的例子里，字符串变量 content 就扮演着一个 DOM Fragment 的角色。其实无论字符串变量也好，DOM Fragment 也罢，它们本质上都作为脱离了真实 DOM 树的<strong>容器</strong>出现，用于缓存批量化的 DOM 操作。    </p>
<p>前面我们直接用 innerHTML 去拼接目标内容，这样做固然有用，但却不够优雅。相比之下，DOM Fragment 可以帮助我们用更加结构化的方式去达成同样的目的，从而在维持性能的同时，保住我们代码的可拓展和可维护性。我们现在用 DOM Fragment 来改写上面的例子：   </p>
<pre><code class="javascript"><span class="keyword">let</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)
<span class="comment">// 创建一个DOM Fragment对象作为容器</span>
<span class="keyword">let</span> content = <span class="built_in">document</span>.createDocumentFragment()
<span class="keyword">for</span>(<span class="keyword">let</span> count=<span class="number">0</span>;count&lt;<span class="number">10000</span>;count++){
  <span class="comment">// span此时可以通过DOM API去创建</span>
  <span class="keyword">let</span> oSpan = <span class="built_in">document</span>.createElement(<span class="string">"span"</span>)
  oSpan.innerHTML = <span class="string">'我是一个小测试'</span>
  <span class="comment">// 像操作真实DOM一样操作DOM Fragment对象</span>
  content.appendChild(oSpan)
}
<span class="comment">// 内容处理好了,最后再触发真实DOM的更改</span>
container.appendChild(content)</code></pre>
<p>我们运行这段代码，可以得到与前面两种写法相同的运行结果。<br>可以看出，DOM Fragment 对象允许我们像操作真实 DOM 一样去调用各种各样的 DOM API，我们的代码质量因此得到了保证。并且它的身份也非常纯粹：当我们试图将其 append 进真实 DOM 时，它会在乖乖交出自身缓存的所有后代节点后<strong>全身而退</strong>，完美地完成一个容器的使命，而不会出现在真实的 DOM 结构中。这种结构化、干净利落的特性，使得 DOM Fragment 作为经典的性能优化手段大受欢迎，这一点在 jQuery、Vue 等优秀前端框架的源码中均有体现。</p>
<p>相比 DOM 命题的博大精深，一个简单的循环 Demo 显然不能说明所有问题。不过不用着急，在本节，我只希望大家能牢记原理与宏观思路。“药到病除”到这里才刚刚开了个头，下个小节，我们将深挖事件循环机制，从而深入 JS 层面的生产实践。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/28/前端性能优化原理与实践/1网络篇 1：webpack 性能调优与 Gzip 原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qicainiao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qicainiao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/28/前端性能优化原理与实践/1网络篇 1：webpack 性能调优与 Gzip 原理/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-28T19:01:07+08:00">
                2019-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="webpack-性能调优与-Gzip-原理"><a href="#webpack-性能调优与-Gzip-原理" class="headerlink" title="webpack 性能调优与 Gzip 原理"></a>webpack 性能调优与 Gzip 原理</h1><p>从本节开始，我们进入网络层面的性能优化世界。</p>
<p>大家可以从第一节的示意图中看出，我们从输入 URL 到显示页面这个过程中，涉及到网络层面的，有三个主要过程：</p>
<ul>
<li>DNS 解析</li>
<li>TCP 连接</li>
<li>HTTP 请求/响应   </li>
</ul>
<p>对于 DNS 解析和 TCP 连接两个步骤，我们前端可以做的努力非常有限。相比之下，HTTP 连接这一层面的优化才是我们网络优化的核心。因此我们开门见山，抓主要矛盾，直接从 HTTP 开始讲起。</p>
<p>HTTP 优化有两个大的方向：   </p>
<ul>
<li>减少请求次数</li>
<li>减少单次请求所花费的时间   </li>
</ul>
<p>这两个优化点直直地指向了我们日常开发中非常常见的操作——资源的压缩与合并。没错，这就是我们每天用构建工具在做的事情。而时下最主流的构建工具无疑是 webpack，所以我们这节的主要任务就是围绕业界霸主 webpack 来做文章。</p>
<h2 id="webpack-的性能瓶颈"><a href="#webpack-的性能瓶颈" class="headerlink" title="webpack 的性能瓶颈"></a>webpack 的性能瓶颈</h2><p>相信每个用过 webpack 的同学都对“打包”和“压缩”这样的事情烂熟于心。这些老生常谈的特性，我更推荐大家去阅读文档。而关于 webpack 的详细操作，则推荐大家读读这本 <a href="https://juejin.im/book/5a6abad5518825733c144469/section/5a6abad5518825732e2f8546#heading-2" target="_blank" rel="noopener">关于 webpack 的掘金小册</a>，这里我们把注意力放在 webpack 的性能优化上。         </p>
<p>webpack 的优化瓶颈，主要是两个方面：</p>
<ul>
<li>webpack 的构建过程太花时间</li>
<li>webpack 打包的结果体积太大     </li>
</ul>
<h2 id="webpack-优化方案"><a href="#webpack-优化方案" class="headerlink" title="webpack 优化方案"></a>webpack 优化方案</h2><h3 id="构建过程提速策略"><a href="#构建过程提速策略" class="headerlink" title="构建过程提速策略"></a>构建过程提速策略</h3><h4 id="不要让-loader-做太多事情——以-babel-loader-为例"><a href="#不要让-loader-做太多事情——以-babel-loader-为例" class="headerlink" title="不要让 loader 做太多事情——以 babel-loader 为例"></a>不要让 loader 做太多事情——以 babel-loader 为例</h4><p>babel-loader 无疑是强大的，但它也是慢的。</p>
<p>最常见的优化方式是，用 include 或 exclude 来帮我们避免不必要的转译，比如 webpack 官方在介绍 babel-loader 时给出的示例： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          presets: [<span class="string">'@babel/preset-env'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这段代码帮我们规避了对庞大的 node_modules 文件夹或者 bower_components 文件夹的处理。但通过限定文件范围带来的性能提升是有限的。除此之外，如果我们选择开启缓存将转译结果缓存至文件系统，则至少可以将 babel-loader 的工作效率提升两倍。要做到这点，我们只需要为 loader 增加相应的参数设定：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loader: <span class="string">'babel-loader?cacheDirectory=true'</span></span><br></pre></td></tr></table></figure>

<p>以上都是在讨论针对 loader 的配置，但我们的优化范围不止是 loader 们。</p>
<p>举个🌰，尽管我们可以在 loader 配置时通过写入 exclude 去避免 babel-loader 对不必要的文件的处理，但是考虑到这个规则仅作用于这个 loader，像一些类似 UglifyJsPlugin 的 webpack 插件在工作时依然会被这些庞大的第三方库拖累，webpack 构建速度依然会因此大打折扣。所以针对这些庞大的第三方库，我们还需要做一些额外的努力。</p>
<h4 id="不要放过第三方库"><a href="#不要放过第三方库" class="headerlink" title="不要放过第三方库"></a>不要放过第三方库</h4><p>第三方库以 node_modules 为代表，它们庞大得可怕，却又不可或缺。</p>
<p>处理第三方库的姿势有很多，其中，Externals 不够聪明，一些情况下会引发重复打包的问题；而 CommonsChunkPlugin 每次构建时都会重新构建一次 vendor；出于对效率的考虑，我们这里为大家推荐 DllPlugin。</p>
<p>DllPlugin 是基于 Windows 动态链接库（dll）的思想被创作出来的。这个插件会把第三方库单独打包到一个文件中，这个文件就是一个单纯的依赖库。<strong>这个依赖库不会跟着你的业务代码一起被重新打包，只有当依赖自身发生版本变化时才会重新打包</strong>。</p>
<p>用 DllPlugin 处理文件，要分两步走：</p>
<ul>
<li>基于 dll 专属的配置文件，打包 dll 库</li>
<li>基于 webpack.config.js 文件，打包业务代码  </li>
</ul>
<p>以一个基于 React 的简单项目为例，我们的 dll 的配置文件可以编写如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">      <span class="comment">// 依赖的库数组</span></span><br><span class="line">      vendor: [</span><br><span class="line">        <span class="string">'prop-types'</span>,</span><br><span class="line">        <span class="string">'babel-polyfill'</span>,</span><br><span class="line">        <span class="string">'react'</span>,</span><br><span class="line">        <span class="string">'react-dom'</span>,</span><br><span class="line">        <span class="string">'react-router-dom'</span>,</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">      path: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">      filename: <span class="string">'[name].js'</span>,</span><br><span class="line">      library: <span class="string">'[name]_[hash]'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">        <span class="comment">// DllPlugin的name属性需要和libary保持一致</span></span><br><span class="line">        name: <span class="string">'[name]_[hash]'</span>,</span><br><span class="line">        path: path.join(__dirname, <span class="string">'dist'</span>, <span class="string">'[name]-manifest.json'</span>),</span><br><span class="line">        <span class="comment">// context需要和webpack.config.js保持一致</span></span><br><span class="line">        context: __dirname,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>编写完成之后，运行这个配置文件，我们的 dist 文件夹里会出现这样两个文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vendor-manifest.json</span><br><span class="line">vendor.js</span><br></pre></td></tr></table></figure>


<p>vendor.js 不必解释，是我们第三方库打包的结果。这个多出来的 vendor-manifest.json，则用于描述每个第三方库对应的具体路径，我这里截取一部分给大家看下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"vendor_397f9e25e49947b8675d"</span>,</span><br><span class="line">  <span class="string">"content"</span>: &#123;</span><br><span class="line">    <span class="string">"./node_modules/core-js/modules/_export.js"</span>: &#123;</span><br><span class="line">      <span class="string">"id"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">"buildMeta"</span>: &#123;</span><br><span class="line">        <span class="string">"providedExports"</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"./node_modules/prop-types/index.js"</span>: &#123;</span><br><span class="line">      <span class="string">"id"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">"buildMeta"</span>: &#123;</span><br><span class="line">        <span class="string">"providedExports"</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>随后，我们只需在 webpack.config.js 里针对 dll 稍作配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  <span class="comment">// 编译入口</span></span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 目标文件</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">'dist/'</span>),</span><br><span class="line">    filename: <span class="string">'[name].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// dll相关配置</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">      context: __dirname,</span><br><span class="line">      <span class="comment">// manifest就是我们第一步中打包出来的json文件</span></span><br><span class="line">      manifest: <span class="built_in">require</span>(<span class="string">'./dist/vendor-manifest.json'</span>),</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一次基于 dll 的 webpack 构建过程优化，便大功告成了！</p>
<h4 id="Happypack——将-loader-由单进程转为多进程"><a href="#Happypack——将-loader-由单进程转为多进程" class="headerlink" title="Happypack——将 loader 由单进程转为多进程"></a>Happypack——将 loader 由单进程转为多进程</h4><p>大家知道，webpack 是单线程的，就算此刻存在多个任务，你也只能排队一个接一个地等待处理。这是 webpack 的缺点，好在我们的 CPU 是多核的，Happypack 会充分释放 CPU 在多核并发方面的优势，帮我们把任务分解给多个子进程去并发执行，大大提升打包效率。</p>
<p>HappyPack 的使用方法也非常简单，只需要我们把对 loader 的配置转移到 HappyPack 中去就好，我们可以手动告诉 HappyPack 我们需要多少个并发的进程：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HappyPack = <span class="built_in">require</span>(<span class="string">'happypack'</span>)</span><br><span class="line"><span class="comment">// 手动创建进程池</span></span><br><span class="line"><span class="keyword">const</span> happyThreadPool =  HappyPack.ThreadPool(&#123; <span class="attr">size</span>: os.cpus().length &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      ...</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="comment">// 问号后面的查询参数指定了处理这类文件的HappyPack实例的名字</span></span><br><span class="line">        loader: <span class="string">'happypack/loader?id=happyBabel'</span>,</span><br><span class="line">        ...</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">      <span class="comment">// 这个HappyPack的“名字”就叫做happyBabel，和楼上的查询参数遥相呼应</span></span><br><span class="line">      id: <span class="string">'happyBabel'</span>,</span><br><span class="line">      <span class="comment">// 指定进程池</span></span><br><span class="line">      threadPool: happyThreadPool,</span><br><span class="line">      loaders: [<span class="string">'babel-loader?cacheDirectory'</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构建结果体积压缩"><a href="#构建结果体积压缩" class="headerlink" title="构建结果体积压缩"></a>构建结果体积压缩</h3><h4 id="文件结构可视化，找出导致体积过大的原因"><a href="#文件结构可视化，找出导致体积过大的原因" class="headerlink" title="文件结构可视化，找出导致体积过大的原因"></a>文件结构可视化，找出导致体积过大的原因</h4><p>这里为大家介绍一个非常好用的包组成可视化工具——<a href="https://www.npmjs.com/package/webpack-bundle-analyzer" target="_blank" rel="noopener">webpack-bundle-analyzer</a>，配置方法和普通的 plugin 无异，它会以矩形树图的形式将包内各个模块的大小和依赖关系呈现出来，格局如官方所提供这张图所示：   </p>
<!--![](https://user-gold-cdn.xitu.io/2018/9/13/165d2e78167482c1?w=1464&h=882&f=png&s=480683)-->

<p><img src="https://user-gold-cdn.xitu.io/2018/9/14/165d838010b20a4c?w=908&h=547&f=gif&s=3663774" alt>   </p>
<p>在使用时，我们只需要将其以插件的形式引入：   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BundleAnalyzerPlugin = <span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>).BundleAnalyzerPlugin;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> BundleAnalyzerPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="拆分资源"><a href="#拆分资源" class="headerlink" title="拆分资源"></a>拆分资源</h4><p>这点仍然围绕 DllPlugin 展开，可参考上文。</p>
<h4 id="删除冗余代码"><a href="#删除冗余代码" class="headerlink" title="删除冗余代码"></a>删除冗余代码</h4><p>一个比较典型的应用，就是 <code>Tree-Shaking</code>。      </p>
<p>从 webpack2 开始，webpack 原生支持了 ES6 的模块系统，并基于此推出了 Tree-Shaking。webpack 官方是这样介绍它的：</p>
<blockquote>
<p>Tree shaking is a term commonly used in the JavaScript context for dead-code elimination, or more precisely, live-code import. It relies on ES2015 module import/export for the static structure of its module system. </p>
</blockquote>
<p>意思是基于 import/export 语法，Tree-Shaking 可以在编译的过程中获悉哪些模块并没有真正被使用，这些没用的代码，在最后打包的时候会被去除。</p>
<p>举个🌰，假设我的主干文件（入口文件）是这么写的：    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; page1, page2 &#125; <span class="keyword">from</span> <span class="string">'./pages'</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// show是事先定义好的函数，大家理解它的功能是展示页面即可</span></span><br><span class="line">show(page1)</span><br></pre></td></tr></table></figure>


<p>pages 文件里，我虽然导出了两个页面：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> page1 = xxx</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> page2 = xxx</span><br></pre></td></tr></table></figure>

<p>但因为 page2 事实上并没有被用到（这个没有被用到的情况在静态分析的过程中是可以被感知出来的），所以打包的结果里会把这部分：    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> page2 = xxx;</span><br></pre></td></tr></table></figure>


<p>直接删掉，这就是 Tree-Shaking 帮我们做的事情。   </p>
<p>相信大家不难看出，Tree-Shaking 的针对性很强，它更适合用来处理模块级别的冗余代码。至于<strong>粒度更细</strong>的冗余代码的去除，往往会被整合进 JS 或 CSS 的压缩或分离过程中。</p>
<p>这里我们以当下接受度较高的 UglifyJsPlugin 为例，看一下如何在压缩过程中对碎片化的冗余代码（如 console 语句、注释等）进行自动化删除：    </p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UglifyJsPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">      <span class="comment">// 允许并发</span></span><br><span class="line">      parallel: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 开启缓存</span></span><br><span class="line">      cache: <span class="literal">true</span>,</span><br><span class="line">      compress: &#123;</span><br><span class="line">        <span class="comment">// 删除所有的console语句    </span></span><br><span class="line">        drop_console: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 把使用多次的静态值自动定义为变量</span></span><br><span class="line">        reduce_vars: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      output: &#123;</span><br><span class="line">        <span class="comment">// 不保留注释</span></span><br><span class="line">        comment: <span class="literal">false</span>,</span><br><span class="line">        <span class="comment">// 使输出的代码尽可能紧凑</span></span><br><span class="line">        beautify: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有心的同学会注意到，这段手动引入 UglifyJsPlugin 的代码其实是 webpack3 的用法，webpack4 现在已经默认使用 uglifyjs-webpack-plugin 对代码做压缩了——在 webpack4 中，我们是通过配置 optimization.minimize 与 optimization.minimizer 来自定义压缩相关的操作的。</p>
<p>这里也引出了我们学习性能优化的一个核心的理念——用什么工具，怎么用，并不是我们这本小册的重点，因为所有的工具都存在用法迭代的问题。但现在大家知道了在打包的过程中做一些如上文所述的“手脚”可以实现打包结果的最优化，那下次大家再去执行打包操作，会不会对这个操作更加留心，从而自己去寻找彼时操作的具体实现方案呢？我最希望大家掌握的技能就是，先在脑海中留下“这个xx操作是对的，是有用的”，在日后的实践中，可以基于这个认知去寻找把正确的操作落地的具体方案。</p>
<h4 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h4><p>大家想象这样一个场景。我现在用 React 构建一个单页应用，用 React-Router 来控制路由，十个路由对应了十个页面，这十个页面都不简单。如果我把这整个项目打一个包，用户打开我的网站时，会发生什么？有很大机率会卡死，对不对？更好的做法肯定是先给用户展示主页，其它页面等请求到了再加载。当然这个情况也比较极端，但却能很好地引出按需加载的思想：  </p>
<ul>
<li><p>一次不加载完所有的文件内容，只加载此刻需要用到的那部分（会提前做拆分）</p>
</li>
<li><p>当需要更多内容时，再对用到的内容进行即时加载</p>
</li>
</ul>
<p>好，既然说到这十个 Router 了，我们就拿其中一个开刀，假设我这个 Router 对应的组件叫做 BugComponent，来看看我们如何利用 webpack 做到该组件的按需加载。</p>
<p>当我们不需要按需加载的时候，我们的代码是这样的：    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> BugComponent <span class="keyword">from</span> <span class="string">'../pages/BugComponent'</span></span><br><span class="line">...</span><br><span class="line">&lt;Route path=<span class="string">"/bug"</span> component=&#123;BugComponent&#125;&gt;</span><br></pre></td></tr></table></figure>

<p>为了开启按需加载，我们要稍作改动。 </p>
<p>首先 webpack 的配置文件要走起来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">'/../dist'</span>),</span><br><span class="line">    filename: <span class="string">'app.js'</span>,</span><br><span class="line">    publicPath: defaultSettings.publicPath,</span><br><span class="line">    <span class="comment">// 指定 chunkFilename</span></span><br><span class="line">    chunkFilename: <span class="string">'[name].[chunkhash:5].chunk.js'</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>路由处的代码也要做一下配合：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getComponent =&gt; (location, cb) &#123;</span><br><span class="line">  <span class="built_in">require</span>.ensure([], (<span class="built_in">require</span>) =&gt; &#123;</span><br><span class="line">    cb(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">'../pages/BugComponent'</span>).default)</span><br><span class="line">  &#125;, <span class="string">'bug'</span>)</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br><span class="line">&lt;Route path=<span class="string">"/bug"</span> getComponent=&#123;getComponent&#125;&gt;</span><br></pre></td></tr></table></figure>


<p>对，核心就是这个方法：   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.ensure(dependencies, callback, chunkName)</span><br></pre></td></tr></table></figure>

<p>这是一个异步的方法，webpack 在打包时，BugComponent 会被单独打成一个文件，只有在我们跳转 bug 这个路由的时候，这个异步方法的回调才会生效，才会真正地去获取 BugComponent 的内容。这就是按需加载。  </p>
<p>按需加载的粒度，还可以继续细化，细化到更小的组件、细化到某个功能点，都是 ok 的。   </p>
<p>等等，这和说好的不一样啊？不是说 Code-Splitting 才是 React-Router 的按需加载实践吗？</p>
<p>没错，在 React-Router4 中，我们确实是用 Code-Splitting 替换掉了楼上这个操作。而且如果有使用过 React-Router4 实现过路由级别的按需加载的同学，可能会对 React-Router4 里用到的一个叫“Bundle-Loader”的东西印象深刻。我想很多同学读到按需加载这里，心里的预期或许都是时下大热的 Code-Splitting，而非我呈现出来的这段看似“陈旧”的代码。</p>
<p>但是，如果大家稍微留个心眼，去看一下 Bundle Loader 并不长的源代码的话，你会发现它竟然还是使用 require.ensure 来实现的——这也是我要把 require.ensure 单独拎出来的重要原因。所谓按需加载，根本上就是在正确的时机去触发相应的回调。理解了这个 require.ensure 的玩法，大家甚至可以结合业务自己去修改一个按需加载模块来用。    </p>
<p>这也应了我之前跟大家强调那段话，工具永远在迭代，唯有掌握核心思想，才可以真正做到举一反三——唯“心”不破！   </p>
<h2 id="彩蛋：Gzip-压缩原理"><a href="#彩蛋：Gzip-压缩原理" class="headerlink" title="彩蛋：Gzip 压缩原理"></a>彩蛋：Gzip 压缩原理</h2><p>恭喜大家迎来了本小册的第一个彩蛋。彩蛋为选学内容，以原理性知识为主。意在拓宽大家的技术视野，加深大家对优化相关知识的理解。   </p>
<p>前面说了不少 webpack 的故事，目的还是帮大家更好地实现压缩和合并。说到压缩，可不只是构建工具的专利。我们日常开发中，其实还有一个便宜又好用的压缩操作：开启 Gzip。      </p>
<p>具体的做法非常简单，只需要你在你的 request headers 中加上这么一句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">accept-encoding:gzip</span><br></pre></td></tr></table></figure>

<p>相信很多同学对 Gzip 也是了解到这里。之所以为大家开这个彩蛋性的小节，绝不是出于炫技要来给大家展示一下 Gzip 的压缩算法，而是想和大家聊一个和我们前端关系更密切的话题：HTTP 压缩。</p>
<blockquote>
<p>HTTP 压缩是一种内置到网页服务器和网页客户端中以改进传输速度和带宽利用率的方式。在使用 HTTP 压缩的情况下，HTTP 数据在从服务器发送前就已压缩：兼容的浏览器将在下载所需的格式前宣告支持何种方法给服务器；不支持压缩方法的浏览器将下载未经压缩的数据。最常见的压缩方案包括 Gzip 和 Deflate。</p>
</blockquote>
<p>以上是摘自百科的解释，事实上，大家可以这么理解： </p>
<p><strong>HTTP 压缩就是以缩小体积为目的，对 HTTP 内容进行重新编码的过程</strong>    </p>
<p>Gzip 的内核就是 Deflate，目前我们压缩文件用得最多的就是 Gzip。可以说，Gzip 就是 HTTP 压缩的经典例题。     </p>
<h3 id="该不该用-Gzip"><a href="#该不该用-Gzip" class="headerlink" title="该不该用 Gzip"></a>该不该用 Gzip</h3><p>如果你的项目不是极端迷你的超小型文件，我都建议你试试 Gzip。</p>
<p>有的同学或许存在这样的疑问：压缩 Gzip，服务端要花时间；解压 Gzip，浏览器要花时间。中间节省出来的传输时间，真的那么可观吗？   </p>
<p>答案是肯定的。如果你手上的项目是 1k、2k 的小文件，那确实有点高射炮打蚊子的意思，不值当。但更多的时候，我们处理的都是具备一定规模的项目文件。实践证明，这种情况下压缩和解压带来的时间开销相对于传输过程中节省下的时间开销来说，可以说是微不足道的。    </p>
<h3 id="Gzip-是万能的吗"><a href="#Gzip-是万能的吗" class="headerlink" title="Gzip 是万能的吗"></a>Gzip 是万能的吗</h3><p>首先要承认 Gzip 是高效的，压缩后<strong>通常</strong>能帮我们减少响应 70% 左右的大小。</p>
<p>但它并非万能。Gzip 并不保证针对每一个文件的压缩都会使其变小。</p>
<p>Gzip 压缩背后的原理，是在一个文本文件中找出一些重复出现的字符串、临时替换它们，从而使整个文件变小。根据这个原理，文件中代码的重复率越高，那么压缩的效率就越高，使用 Gzip 的收益也就越大。反之亦然。    </p>
<h3 id="webpack-的-Gzip-和服务端的-Gzip"><a href="#webpack-的-Gzip-和服务端的-Gzip" class="headerlink" title="webpack 的 Gzip 和服务端的 Gzip"></a>webpack 的 Gzip 和服务端的 Gzip</h3><p>一般来说，Gzip 压缩是服务器的活儿：服务器了解到我们这边有一个 Gzip 压缩的需求，它会启动自己的 CPU 去为我们完成这个任务。而压缩文件这个过程本身是需要耗费时间的，大家可以理解为我们以服务器压缩的时间开销和 CPU 开销（以及浏览器解析压缩文件的开销）为代价，省下了一些传输过程中的时间开销。       </p>
<p>既然存在着这样的交换，那么就要求我们学会权衡。服务器的 CPU 性能不是无限的，如果存在大量的压缩需求，服务器也扛不住的。服务器一旦因此慢下来了，用户还是要等。Webpack 中 Gzip 压缩操作的存在，事实上就是为了在构建过程中去做一部分服务器的工作，为服务器分压。  </p>
<p>因此，这两个地方的 Gzip 压缩，谁也不能替代谁。它们必须和平共处，好好合作。作为开发者，我们也应该结合业务压力的实际强度情况，去做好这其中的权衡。      </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>说了这么多，我们都在讨论文件——准确地说，是文本文件及其构建过程的优化。   </p>
<p>但一个完整的现代前端应用，除了要包含 HTML、CSS 和 JS，往往还需要借助图片来提高用户的视觉体验。而图片优化的思路、场景与措施，又是另外一个说来话长的故事了。下面，我们就一起进入图片的小天地，一窥究竟。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/28/前端性能优化原理与实践/13性能监测篇：Performance、LightHouse 与性能 API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qicainiao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qicainiao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/28/前端性能优化原理与实践/13性能监测篇：Performance、LightHouse 与性能 API/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-28T19:01:07+08:00">
                2019-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Performance、LightHouse-与性能-API"><a href="#Performance、LightHouse-与性能-API" class="headerlink" title="Performance、LightHouse 与性能 API"></a>Performance、LightHouse 与性能 API</h1><p>性能监测是前端性能优化的重要一环。监测的目的是为了确定性能瓶颈，从而有的放矢地开展具体的优化工作。   </p>
<p>平时我们比较推崇的性能监测方案主要有两种：<strong>可视化方案、可编程方案</strong>。这两种方案下都有非常优秀、且触手可及的相关工具供大家选择，本节我们就一起来研究一下这些工具的用法。    </p>
<h2 id="可视化监测：从-Performance-面板说起"><a href="#可视化监测：从-Performance-面板说起" class="headerlink" title="可视化监测：从 Performance 面板说起"></a>可视化监测：从 Performance 面板说起</h2><p>Performance<br>是<br>Chrome<br>提供给我们的开发者工具，用于记录和分析我们的应用在运行时的所有活动。它呈现的数据具有实时性、多维度的特点，可以帮助我们很好地定位性能问题。 </p>
<h3 id="开始记录"><a href="#开始记录" class="headerlink" title="开始记录"></a>开始记录</h3><p>右键打开开发者工具，选中我们的<br>Performance<br>面板：   </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/7/1664d6a13652f0db?w=1870&h=1108&f=png&s=159205" alt></p>
<p>当我们选中图中所标示的实心圆按钮，Performance<br>会开始帮我们记录我们后续的交互操作；当我们选中圆箭头按钮，Performance<br>会将页面重新加载，计算加载过程中的性能表现。<br>tips：使用<br>Performance<br>工具时，为了规避其它<br>Chrome<br>插件对页面的性能影响，我们最好在无痕模式下打开页面：   </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/7/1664d6cba417ba48?w=732&h=194&f=png&s=29760" alt></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/7/1664d6d61365b9fd?w=1258&h=848&f=png&s=134455" alt>   </p>
<h3 id="简要分析"><a href="#简要分析" class="headerlink" title="简要分析"></a>简要分析</h3><p>这里我打开掘金首页，选中 Performance 面板中的圆箭头，来看一下页面加载过程中的性能表现：   </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/7/1664d714642f4dcb?w=1874&h=1220&f=png&s=210945" alt></p>
<p>从上到下，依次为概述面板、详情面板。下我们先来观察一下概述面板，了解页面的基本表现：</p>
<p>  <img src="https://user-gold-cdn.xitu.io/2018/10/7/1664d75451ddcd18?w=1874&h=210&f=png&s=43009" alt> </p>
<p>我们看右上角的三个栏目：FPS、CPU 和 NET。</p>
<p><strong>FPS</strong>：这是一个和动画性能密切相关的指标，它表示每一秒的帧数。图中绿色柱状越高表示帧率越高，体验就越流畅。若出现红色块，则代表长时间帧，很可能会出现卡顿。图中以绿色为主，偶尔出现红块，说明网页性能并不糟糕，但仍有可优化的空间。</p>
<p><strong>CPU</strong>：表示CPU的使用情况，不同的颜色片段代表着消耗CPU资源的不同事件类型。这部分的图像和下文详情面板中的Summary内容有对应关系，我们可以结合这两者挖掘性能瓶颈。</p>
<p><strong>NET</strong>：粗略的展示了各请求的耗时与前后顺序。这个指标一般来说帮助不大。</p>
<h3 id="挖掘性能瓶颈"><a href="#挖掘性能瓶颈" class="headerlink" title="挖掘性能瓶颈"></a>挖掘性能瓶颈</h3><p>详情面板中的内容有很多。但一般来说，我们会主要去看 Main 栏目下的火焰图和 Summary 提供给我们的饼图——这两者和概述面板中的 CPU 一栏结合，可以帮我们迅速定位性能瓶颈（如下图）。   </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/7/1664d9d24ee5bd4e?w=1874&h=920&f=png&s=179700" alt>   </p>
<p>先看 CPU 图表和 Summary 饼图。CPU 图表中，我们可以根据颜色填充的饱满程度，确定 CPU 的忙闲，进而了解该页面的总的任务量。而 Summary 饼图则以一种直观的方式告诉了我们，哪个类型的任务最耗时（从本例来看是脚本执行过程）。这样我们在优化的时候，就可以抓到“主要矛盾”，进而有的放矢地开展后续的工作了。  </p>
<p>再看 Main 提供给我们的火焰图。这个火焰图非常关键，它展示了整个运行时主进程所做的每一件事情（包括加载、脚本运行、渲染、布局、绘制等）。x 轴表示随时间的记录。每个长条就代表一个活动。更宽的条形意味着事件需要更长时间。y 轴表示调用堆栈，我们可以看到事件是相互堆叠的，上层的事件触发了下层的事件。   </p>
<p>CPU 图标和 Summary 图都是按照“类型”给我们提供性能信息，而 Main 火焰图则将粒度细化到了每一个函数的调用。到底是从哪个过程开始出问题、是哪个函数拖了后腿、又是哪个事件触发了这个函数，这些具体的、细致的问题都将在 Main 火焰图中得到解答。   </p>
<h2 id="可视化监测：-更加聪明的-LightHouse"><a href="#可视化监测：-更加聪明的-LightHouse" class="headerlink" title="可视化监测： 更加聪明的 LightHouse"></a>可视化监测： 更加聪明的 LightHouse</h2><p>Performance 无疑可以为我们提供很多有价值的信息，但它的展示作用大于分析作用。它要求使用者对工具本身及其所展示的信息有充分的理解，能够将晦涩的数据“翻译”成具体的性能问题。    </p>
<p>程序员们许了个愿：如果工具能帮助我们把页面的问题也分析出来就好了！上帝听到了这个愿望，于是给了我们 LightHouse：    </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/7/1664db3f31e0b6a6" alt>   </p>
<blockquote>
<p>Lighthouse 是一个开源的自动化工具，用于改进网络应用的质量。 你可以将其作为一个 Chrome 扩展程序运行，或从命令行运行。 为Lighthouse 提供一个需要审查的网址，它将针对此页面运行一连串的测试，然后生成一个有关页面性能的报告。   </p>
</blockquote>
<p>敲黑板划重点：它生成的是一个报告！Report！不是干巴巴地数据，而是一个通过测试与分析呈现出来的结果（它甚至会给你的页面跑一个分数出来）。这个东西看起来也真是太赞了，我们这就来体验一下！    </p>
<p>首先在 Chrome 的应用商店里下载一个 LightHouse。这一步 OK 之后，我们浏览器右上角会出现一个小小的灯塔 ICON。打开我们需要测试的那个页面，点击这个 ICON，唤起如下的面板：   </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/7/1664db9c661bfee3?w=912&h=634&f=png&s=79733" alt>  </p>
<p>然后点击“Generate report”按钮，只需静候数秒，LightHouse 就会为我们输出一个完美的性能报告。   </p>
<p>这里我拿掘金小册首页“开刀”：   </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/7/1664dbdb110cb4ee?w=2674&h=1378&f=png&s=395843" alt>    </p>
<p>稍事片刻，Report 便输出成功了，LightHouse 默认会帮我们打开一个新的标签页来展示报告内容。报告内容非常丰富，首先我们看到的是整体的跑分情况：   </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/7/1664dc4798ee8992?w=1932&h=708&f=png&s=212488" alt></p>
<p>上述分别是页面性能、PWA（渐进式 Web 应用）、可访问性（无障碍）、最佳实践、SEO 五项指标的跑分。孰强孰弱，我们一看便知。</p>
<p>向下拉动 Report 页，我们还可以看到每一个指标的细化评估：   </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/7/1664dc86aeeda780?w=1668&h=1034&f=png&s=185822" alt>   </p>
<p>在“Opportunities”中，LightHouse 甚至针对我们的性能问题给出了可行的建议、以及每一项优化操作预期会帮我们节省的时间。这份报告的可操作性是很强的——我们只需要对着 LightHouse 给出的建议，一条一条地去尝试，就可以看到自己的页面，在一秒一秒地变快。   </p>
<p>除了直接下载，我们还可以通过命令行使用 LightHouse： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g lighthouse</span><br><span class="line">lighthouse https://juejin.im/books</span><br></pre></td></tr></table></figure>

<p>同样可以得到掘金小册的性能报告。</p>
<p>此外，从 Chrome 60 开始，DevTools 中直接加入了基于 LightHouse 的 Audits 面板：   </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/7/1664dd0337d66bfe?w=1788&h=1184&f=png&s=181265" alt></p>
<p>LightHouse 因此变得更加触手可及了，这一操作也足以证明 Chrome 团队对 LightHouse 的推崇。   </p>
<h2 id="可编程的性能上报方案：-W3C-性能-API"><a href="#可编程的性能上报方案：-W3C-性能-API" class="headerlink" title="可编程的性能上报方案： W3C 性能 API"></a>可编程的性能上报方案： W3C 性能 API</h2><p>W3C 规范为我们提供了 Performance 相关的接口。它允许我们获取到用户访问一个页面的每个阶段的精确时间，从而对性能进行分析。我们可以将其理解为 Performance 面板的进一步细化与可编程化。    </p>
<p>当下的前端世界里，数据可视化的概念已经被炒得非常热了，Performance 面板就是数据可视化的典范。那么为什么要把已经可视化的数据再掏出来处理一遍呢？这是因为，需要这些数据的人不止我们前端——很多情况下，后端也需要我们提供性能信息的上报。此外，Performance 提供的可视化结果并不一定能够满足我们实际的业务需求，只有拿到了真实的数据，我们才可以对它进行二次处理，去做一个更加深层次的可视化。   </p>
<p>在这种需求背景下，我们就不得不祭出 Performance API了。</p>
<h3 id="访问-performance-对象"><a href="#访问-performance-对象" class="headerlink" title="访问 performance 对象"></a>访问 performance 对象</h3><p>performance 是一个全局对象。我们在控制台里输入 window.performance，就可一窥其全貌：  </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/7/1664dd8ec761f69f?w=1868&h=336&f=png&s=141570" alt> </p>
<h3 id="关键时间节点"><a href="#关键时间节点" class="headerlink" title="关键时间节点"></a>关键时间节点</h3><p>在 performance 的 timing 属性中，我们可以查看到如下的时间戳：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/7/1664dddde131e37a?w=854&h=712&f=png&s=199170" alt></p>
<p>这些时间戳与页面整个加载流程中的关键时间节点有着一一对应的关系：   </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/7/1664ddd4e3df9a14?w=1473&h=879&f=png&s=62923" alt></p>
<p>通过求两个时间点之间的差值，我们可以得出某个过程花费的时间，举个🌰：     </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> timing = <span class="built_in">window</span>.performance.timing</span><br><span class="line"><span class="comment">// DNS查询耗时</span></span><br><span class="line">timing.domainLookupEnd - timing.domainLookupStart</span><br><span class="line">  </span><br><span class="line"><span class="comment">// TCP连接耗时</span></span><br><span class="line">timing.connectEnd - timing.connectStart</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 内容加载耗时</span></span><br><span class="line">timing.responseEnd - timing.requestStart</span><br><span class="line"></span><br><span class="line">···</span><br><span class="line"><span class="string">``</span><span class="string">`   </span></span><br><span class="line"><span class="string">除了这些常见的耗时情况，我们更应该去关注一些**关键性能指标**：firstbyte、fpt、tti、ready 和 load 时间。这些指标数据与真实的用户体验息息相关，是我们日常业务性能监测中不可或缺的一部分：   </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="comment">// firstbyte：首包时间	</span></span><br><span class="line">timing.responseStart – timing.domainLookupStart	</span><br><span class="line"></span><br><span class="line"><span class="comment">// fpt：First Paint Time, 首次渲染时间 / 白屏时间</span></span><br><span class="line">timing.responseEnd – timing.fetchStart</span><br><span class="line"></span><br><span class="line"><span class="comment">// tti：Time to Interact，首次可交互时间	</span></span><br><span class="line">timing.domInteractive – timing.fetchStart</span><br><span class="line"></span><br><span class="line"><span class="comment">// ready：HTML 加载完成时间，即 DOM 就位的时间</span></span><br><span class="line">timing.domContentLoaded – timing.fetchStart</span><br><span class="line"></span><br><span class="line"><span class="comment">// load：页面完全加载时间</span></span><br><span class="line">timing.loadEventStart – timing.fetchStart</span><br></pre></td></tr></table></figure>

<p>以上这些通过 Performance API 获取到的时间信息都具有较高的准确度。我们可以对此进行一番格式处理之后上报给服务端，也可以基于此去制作相应的统计图表，从而实现更加精准、更加个性化的性能耗时统计。   </p>
<p>此外，通过访问 performance 的 memory 属性，我们还可以获取到内存占用相关的数据；通过对 performance 的其它属性方法的灵活运用，我们还可以把它耦合进业务里，实现更加多样化的性能监测需求——灵活，是可编程化方案最大的优点。    </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本节我们介绍了 Performance 开发者工具、LightHouse 与 Performance API 三种性能监测的方案。只要有 Chrome 浏览器，我们就可以实现上述的所有操作。    </p>
<p>由此可以看出，性能监测本身并不难。它的复杂度是在与业务发生耦合的过程中提升的。我们今天打下了坚实的地基，后续需要大家在业务中去成长、去发掘这些工具的更多的潜力，这样才能建立起属于我们自己的技术金字塔。    </p>
<p>推荐阅读：   </p>
<ul>
<li><p><a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference" target="_blank" rel="noopener">Performance 官方文档</a> </p>
</li>
<li><p><a href="https://developers.google.com/web/tools/lighthouse/?hl=zh-cn" target="_blank" rel="noopener">使用 Lighthouse 审查网络应用
</a> </p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance" target="_blank" rel="noopener">MDN Performance API 介绍</a> </p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/28/前端性能优化原理与实践/0开篇：知识体系与小册格局/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qicainiao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qicainiao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/28/前端性能优化原理与实践/0开篇：知识体系与小册格局/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-28T19:01:07+08:00">
                2019-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="知识体系与小册格局"><a href="#知识体系与小册格局" class="headerlink" title="知识体系与小册格局"></a>知识体系与小册格局</h1><h2 id="写给读者"><a href="#写给读者" class="headerlink" title="写给读者"></a>写给读者</h2><p>提起性能优化，大家现在脑海里第一时间会映射出什么内容呢？</p>
<p>可能是类似<a href="https://developer.yahoo.com/performance/rules.html?guccounter=1" target="_blank" rel="noopener">“雅虎军规”</a>和<a href="https://book.douban.com/subject/5362856/" target="_blank" rel="noopener">《高性能 JavaScript》</a>这样历久弥香的经典之作，也可能是搜索引擎聚合给你的一篇又一篇以性能优化为主题的个人或团队实践而来的“私货”。至少当我确定自己的研发方向、并接到第一个性能优化任务时，我做的第一件事是向搜索引擎求助，第二件事是买书，然后开始了摸着石头过河，前后花费了大量的时间和精力。我深感性能优化实在是前端知识树中特别的一环——当你需要学习前端框架时，文档和源码几乎可以告诉你所有问题的答案，当你需要学习 Git 时，你也可以找到放之四海皆准的实践方案。但性能优化却不一样，它好像只能是一个摸索的过程。  </p>
<p>这个摸索的过程是痛苦的、漫长的，也是紧要的。因为在如今的互联网环境下，一个前端团队如果只把性能优化这个任务写在纸上，而不投入实践，它将缺失最基本的竞争力。    </p>
<p>笔者写这本小册，是希望通过短短十数个章节的讲解，尽可能降低一些大家学习性能优化的成本。  </p>
<p>一方面，这本小册为没有接触过性能优化的新同学建立起一个正确的前端性能优化的“世界观”，知道性能优化是什么、为什么、怎么做，从而使性能优化这件事情有迹可循，有路可走。这样在面试现场被问到性能优化层面的问题时，能够做到滔滔不绝、言之有物，而非像背书一样罗列干巴巴的知识点，最终淹没在茫茫的求职大军中。另一方面，小册可以为在职的工程师们提供一线团队已经实践过的“方法论”，知道什么场景下该做什么事情，最终在脑海中留下一张涵盖核心原理和实践的、可随时查阅并且高度可扩展的性能优化思路索引表。然后在今后的开发生活中可以去践行它，更进一步去挖掘它。把性能优化变作你前端工程师生涯的一门必修课，进而演化为自己研发方面的核心竞争力。       </p>
<p>同时，相信大家可以明确这样一个学习观念：任何技术的掌握，都离不开一定比例的理论基础和实际操作的支撑。</p>
<p>具体到前端性能优化这件事情上，我认为它是 20% 的理论，加上至少 80% 的实践，甚至很多理论本身也都是我们在具体的业务场景中实践出来的。所以希望大家阅读本小册时，能够读到一些“书本之外的东西”——最好是一边读一边回忆自己既有的开发经历，尝试去留意哪些知识是已知的，哪些是未知的。 </p>
<p>这样读完之后，就可以有的放矢地把这些知识转换为自己的项目实践——前端技术日新月异，性能方案永远都在更迭，所以一定要形成自己的学习思路。   </p>
<p>建议每一位读者都带着“学了就要用”的心态去读这本小册。如果阅读结束，能够为你带来哪怕一个小小的开发习惯或者优化观念上的改变，这数小时的阅读时间就算没有白费。  </p>
<h2 id="知识体系：-从一道面试题说起"><a href="#知识体系：-从一道面试题说起" class="headerlink" title="知识体系： 从一道面试题说起"></a>知识体系： 从一道面试题说起</h2><p>在展开性能优化的话题之前，我想先抛出一个老生常谈的面试问题：   </p>
<blockquote>
<p>从输入 URL 到页面加载完成，发生了什么？   </p>
</blockquote>
<p>这个问题非常重要，因为我们后续的内容都将以这个问题的答案为骨架展开。我希望正在阅读这本小册的各位可以在心里琢磨一下这个问题——无须你调动太多计算机的专业知识，只需要你用最快的速度在脑海中架构起这个抽象的过程——我们接下来所有的工作，就是围绕这个过程来做文章。       </p>
<p>我们现在站在性能优化的角度，一起简单地复习一遍这个经典的过程：首先我们需要通过 DNS（域名解析系统）将 URL 解析为对应的 IP 地址，然后与这个 IP 地址确定的那台服务器建立起 TCP 网络连接，随后我们向服务端抛出我们的 HTTP 请求，服务端处理完我们的请求之后，把目标数据放在 HTTP 响应里返回给客户端，拿到响应数据的浏览器就可以开始走一个渲染的流程。渲染完毕，页面便呈现给了用户，并时刻等待响应用户的操作（如下图所示）。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/18/16685737b823244c?w=489&h=329&f=png&s=19023" alt></p>
<p>我们将这个过程切分为如下的过程片段：</p>
<ol>
<li>DNS 解析</li>
<li>TCP 连接</li>
<li>HTTP 请求抛出</li>
<li>服务端处理请求，HTTP 响应返回</li>
<li>浏览器拿到响应数据，解析响应内容，把解析的结果展示给用户</li>
</ol>
<p>大家谨记，我们任何一个用户端的产品，都需要把这 5 个过程滴水不漏地考虑到自己的性能优化方案内、反复权衡，从而打磨出用户满意的速度。       </p>
<h2 id="从原理到实践：各个击破"><a href="#从原理到实践：各个击破" class="headerlink" title="从原理到实践：各个击破"></a>从原理到实践：各个击破</h2><p>我们接下来要做的事情，就是针对这五个过程进行分解，各个提问，各个击破。</p>
<p>具体来说，DNS 解析花时间，能不能尽量减少解析次数或者把解析前置？能——浏览器 DNS 缓存和 DNS prefetch。TCP 每次的三次握手都急死人，有没有解决方案？有——长连接、预连接、接入 SPDY 协议。如果说这两个过程的优化往往需要我们和团队的服务端工程师协作完成，前端单方面可以做的努力有限，那么 HTTP 请求呢？——在减少请求次数和减小请求体积方面，我们应该是专家！再者，服务器越远，一次请求就越慢，那部署时就把静态资源放在离我们更近的 CDN 上是不是就能更快一些？     </p>
<p>以上提到的都是网络层面的性能优化。再往下走就是浏览器端的性能优化——这部分涉及资源加载优化、服务端渲染、浏览器缓存机制的利用、DOM 树的构建、网页排版和渲染过程、回流与重绘的考量、DOM 操作的合理规避等等——这正是前端工程师可以真正一展拳脚的地方。学习这些知识，不仅可以帮助我们从根本上提升页面性能，更能够大大加深个人对浏览器底层原理、运行机制的理解，一举两得！    </p>
<p>我们整个的知识图谱，用思维导图展示如下：    </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/23/1669f5358f63c0f8?w=2478&h=1506&f=png&s=340672" alt> </p>
<h2 id="小册格局"><a href="#小册格局" class="headerlink" title="小册格局"></a>小册格局</h2><p>总的来说，我们将从<strong>网络层面</strong>和<strong>渲染层面</strong>两个大的维度来逐个点亮前端性能优化的技能树。     </p>
<p>这两个维度的知识面貌各有千秋：在网络层面，我们需要学习一些必需的理论基础作为前置知识。这部分的学习或许不需要大家写特别多的代码，但需要大家对每一个知识点理解透彻，进而应用到自己日常优化的决策中去。网络层面结束后，由本地存储开始，我们会渐渐过渡到浏览器这一端的优化，大家喜闻乐见的“真代码”就会相应地多起来。</p>
<p>为了使同学们耐心学习一些理论性稍强的知识，我也会尽自己所能去讲述得有趣、易读、可用，同时希望大家可以真的沉下心去理解这些知识，它们与大家喜闻乐见的框架和工具无异，一样是实实在在的生产力。       </p>
<p>“经验丰富的人读书用两只眼睛，一只眼睛看到纸面上的话，另一只眼睛看到纸的背面”。在这本小册，代码片段固然有用，它们是“纸面上的话”，我自然希望大家可以记下来、用起来。而代码之外那些反复讲解的原理，则是“纸的背面”，同样是我希望引起大家重视的内容。    </p>
<p>现在相信大家已经对我们的优化观念、知识结构、小册格局都有了基本认知，那么我们就赶快趁热打铁，进入实战技能的学习吧~</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">qicainiao</p>
              <p class="site-description motion-element" itemprop="description">Hello World!</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">40</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">qicainiao</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
