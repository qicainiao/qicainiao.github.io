<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="Hello World!">
<meta property="og:type" content="website">
<meta property="og:title" content="qicainiao&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="qicainiao&#39;s Blog">
<meta property="og:description" content="Hello World!">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="qicainiao&#39;s Blog">
<meta name="twitter:description" content="Hello World!">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>qicainiao's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">qicainiao's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/28/前端性能优化原理与实践/11应用篇 1：优化首屏体验——Lazy-Load 初探/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qicainiao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qicainiao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/28/前端性能优化原理与实践/11应用篇 1：优化首屏体验——Lazy-Load 初探/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-28T19:01:07+08:00">
                2019-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="优化首屏体验——Lazy-Load-初探"><a href="#优化首屏体验——Lazy-Load-初探" class="headerlink" title="优化首屏体验——Lazy-Load 初探"></a>优化首屏体验——Lazy-Load 初探</h1><p>首先要告诉大家的是，截止到上个章节，我们需要大家绞尽脑汁去理解的“硬核”操作基本告一段落了。从本节开始，我们会一起去实现一些必知必会、同时难度不大的常用优化手段。    </p>
<p>这部分内容不难，但<strong>很关键</strong>。尤其是近期有校招或跳槽需求的同学，还请务必对这部分内容多加留心，说不定下一次的面试题里就有它们的身影。    </p>
<h2 id="Lazy-Load-初相见"><a href="#Lazy-Load-初相见" class="headerlink" title="Lazy-Load 初相见"></a>Lazy-Load 初相见</h2><p>Lazy-Load，翻译过来是“懒加载”。它是针对图片加载时机的优化：在一些图片量比较大的网站（比如电商网站首页，或者团购网站、小游戏首页等），如果我们尝试在用户打开页面的时候，就把所有的图片资源加载完毕，那么很可能会造成白屏、卡顿等现象，因为图片真的太多了，一口气处理这么多任务，浏览器做不到啊！</p>
<p>但我们再想，用户真的需要这么多图片吗？不对，用户点开页面的瞬间，呈现给他的只有屏幕的一部分（我们称之为首屏）。只要我们可以在页面打开的时候把首屏的图片资源加载出来，用户就会认为页面是没问题的。至于下面的图片，我们完全可以等用户下拉的瞬间再即时去请求、即时呈现给他。这样一来，性能的压力小了，用户的体验却没有变差——这个延迟加载的过程，就是 Lazy-Load。</p>
<p>现在我们打开掘金首页：   </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/5/16642f37c7f20143?w=1424&h=1092&f=png&s=251118" alt></p>
<p>大家留意一栏文章右侧可能会出现的图片，这里咱们给个特写：  </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/5/16642f57149017c9?w=202&h=662&f=png&s=59534" alt>   </p>
<p>大家现在以尽可能快的速度，疯狂向下拉动页面。发现什么？是不是发现我们图示的这个图片的位置，会出现闪动——有时候我们明明已经拉到目标位置了，文字也呈现完毕了，图片却慢半拍才显示出来。这是因为，掘金首页也采用了懒加载策略。当我们的页面并未滚动至包含图片的 div 元素所在的位置时，它的样式是这样的：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/5/16642f9403b5f320?w=1312&h=142&f=png&s=62803" alt>   </p>
<p>我们把代码提出来看一下：   </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-v-b2db8566</span>=<span class="string">""</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">data-v-009ea7bb</span>=<span class="string">""</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">data-v-6b46a625</span>=<span class="string">""</span>   </span></span><br><span class="line"><span class="tag">    <span class="attr">data-src</span>=<span class="string">"https://user-gold-cdn.xitu.io/2018/9/27/16619f449ee24252?imageView2/1/w/120/h/120/q/85/format/webp/interlace/1"</span>    </span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"lazy thumb thumb"</span>    </span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">"background-image: none; background-size: cover;"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们注意到 style 内联样式中，背景图片设置为了 none。也就是说这个 div 是没有内容的，它只起到一个<strong>占位</strong>的作用。   </p>
<p>这个“占位”的概念，在这个例子里或许体现得不够直观。最直观的应该是淘宝首页的 HTML Preview 效果：    </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/5/1664307daf51a16e?w=2290&h=972&f=png&s=125909" alt>  </p>
<p>我们看到，这个还没来得及被图片填充完全的网页，是用大大小小的空 div 元素来占位的。掘金首页也是如此。   </p>
<p>一旦我们通过滚动使得这个 div 出现在了可见范围内，那么 div 元素的内容就会发生变化，呈现如下的内容：   </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/5/1664300e3f14b7c9?w=1198&h=252&f=png&s=109226" alt>  </p>
<p>我们给 style 一个特写：  </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">style="background-image: url(&amp;quot;https://user-gold-cdn.xitu.io/2018/9/27/16619f449ee24252?imageView2/1/w/120/h/120/q/85/format/webp/interlace/1&amp;quot;); background-size: cover;"</span><br></pre></td></tr></table></figure>

<p>可以看出，style 内联样式中的背景图片属性从 none 变成了一个在线图片的 URL。也就是说，出现在可视区域的瞬间，div 元素的内容被即时地修改掉了——它被写入了有效的图片 URL，于是图片才得以呈现。这就是懒加载的实现思路。      </p>
<h2 id="一起写一个-Lazy-Load-吧！"><a href="#一起写一个-Lazy-Load-吧！" class="headerlink" title="一起写一个 Lazy-Load 吧！"></a>一起写一个 Lazy-Load 吧！</h2><p>基于上面的实现思路，我们完全可以手动实现一个属于自己的 Lazy-Load。</p>
<p>（<strong>此处敲黑板划重点，Lazy-Load 的思路及实现方式为大厂面试常考题，还望诸位同学引起重视</strong>）</p>
<p>首先新建一个空项目，目录结构如下：  </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/5/1664322fcf90be3e?w=466&h=116&f=png&s=14252" alt> </p>
<p>大家可以往 images 文件夹里塞入各种各样自己喜欢的图片。</p>
<p>我们在 index.html 中，为这些图片预置 img 标签：    </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Lazy-Load<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    .img &#123;</span><br><span class="line">      width: 200px;</span><br><span class="line">      height:200px;</span><br><span class="line">      background-color: gray;</span><br><span class="line">    &#125;</span><br><span class="line">    .pic &#123;</span><br><span class="line">      // 必要的img样式</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img"</span>&gt;</span></span><br><span class="line">      // 注意我们并没有为它引入真实的src</span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"pic"</span> <span class="attr">alt</span>=<span class="string">"加载中"</span> <span class="attr">data-src</span>=<span class="string">"./images/1.png"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"pic"</span> <span class="attr">alt</span>=<span class="string">"加载中"</span> <span class="attr">data-src</span>=<span class="string">"./images/2.png"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"pic"</span> <span class="attr">alt</span>=<span class="string">"加载中"</span> <span class="attr">data-src</span>=<span class="string">"./images/3.png"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"pic"</span> <span class="attr">alt</span>=<span class="string">"加载中"</span> <span class="attr">data-src</span>=<span class="string">"./images/4.png"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"pic"</span> <span class="attr">alt</span>=<span class="string">"加载中"</span> <span class="attr">data-src</span>=<span class="string">"./images/5.png"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"pic"</span> <span class="attr">alt</span>=<span class="string">"加载中"</span> <span class="attr">data-src</span>=<span class="string">"./images/6.png"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"pic"</span> <span class="attr">alt</span>=<span class="string">"加载中"</span> <span class="attr">data-src</span>=<span class="string">"./images/7.png"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"pic"</span> <span class="attr">alt</span>=<span class="string">"加载中"</span> <span class="attr">data-src</span>=<span class="string">"./images/8.png"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"pic"</span> <span class="attr">alt</span>=<span class="string">"加载中"</span> <span class="attr">data-src</span>=<span class="string">"./images/9.png"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"pic"</span> <span class="attr">alt</span>=<span class="string">"加载中"</span> <span class="attr">data-src</span>=<span class="string">"./images/10.png"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在懒加载的实现中，有两个关键的数值：一个是<strong>当前可视区域的高度</strong>，另一个是<strong>元素距离可视区域顶部的高度</strong>。 </p>
<p><strong>当前可视区域的高度</strong>， 在和现代浏览器及 IE9 以上的浏览器中，可以用 window.innerHeight 属性获取。在低版本 IE 的标准模式中，可以用 document.documentElement.clientHeight 获取，这里我们兼容两种情况：    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> viewHeight = <span class="built_in">window</span>.innerHeight || <span class="built_in">document</span>.documentElement.clientHeight</span><br></pre></td></tr></table></figure>

<p>而<strong>元素距离可视区域顶部的高度</strong>，我们这里选用 getBoundingClientRect() 方法来获取返回元素的大小及其相对于视口的位置。对此 MDN 给出了非常清晰的解释：</p>
<blockquote>
<p>该方法的返回值是一个 DOMRect 对象，这个对象是由该元素的 getClientRects() 方法返回的一组矩形的集合, 即：是与该元素相关的 CSS 边框集合 。 </p>
</blockquote>
<blockquote>
<p>DOMRect 对象包含了一组用于描述边框的只读属性——left、top、right 和 bottom，单位为像素。除了 width 和 height 外的属性都是相对于视口的左上角位置而言的。</p>
</blockquote>
<p>其中需要引起我们注意的就是 left、top、right 和 bottom，它们对应到元素上是这样的：   </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/5/1664360c6ceda200?w=500&h=500&f=png&s=25422" alt>  </p>
<p>可以看出，top 属性代表了元素距离可视区域顶部的高度，正好可以为我们所用！   </p>
<p>Lazy-Load 方法开工啦！</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 获取所有的图片标签</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> imgs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'img'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 获取可视区域的高度</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> viewHeight = <span class="built_in">window</span>.innerHeight || <span class="built_in">document</span>.documentElement.clientHeight</span></span><br><span class="line"><span class="javascript">    <span class="comment">// num用于统计当前显示到了哪一张图片，避免每次都从第一张图片开始检查是否露出</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> num = <span class="number">0</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">lazyload</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span>(<span class="keyword">let</span> i=num; i&lt;imgs.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 用可视区域高度减去元素顶部距离可视区域顶部的高度</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> distance = viewHeight - imgs[i].getBoundingClientRect().top</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 如果可视区域高度大于等于元素顶部距离可视区域顶部的高度，说明元素露出</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span>(distance &gt;= <span class="number">0</span> )&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 给元素写入真实的src，展示图片</span></span></span><br><span class="line"><span class="javascript">                imgs[i].src = imgs[i].getAttribute(<span class="string">'data-src'</span>)</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 前i张图片已经加载完毕，下次从第i+1张开始检查是否露出</span></span></span><br><span class="line">                num = i + 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="comment">// 监听Scroll事件</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, lazyload, <span class="literal">false</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本节我们实现出了一个最基本的懒加载功能。但是大家要注意一点：这个 scroll 事件，是一个<strong>危险</strong>的事件——它太容易被触发了。试想，用户在访问网页的时候，是不是可以无限次地去触发滚动？尤其是一个页面死活加载不出来的时候，疯狂调戏鼠标滚轮（或者浏览器滚动条）的用户可不在少数啊！       </p>
<p>再回头看看我们上面写的代码。按照我们的逻辑，用户的每一次滚动都将触发我们的监听函数。函数执行是吃性能的，频繁地响应某个事件将造成大量不必要的页面计算。因此，我们需要针对那些有可能被频繁触发的事件作进一步地优化。这里就引出了我们下一节的两位主角——throttle 与 debounce。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/28/前端性能优化原理与实践/3存储篇 1：浏览器缓存机制介绍与缓存策略剖析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qicainiao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qicainiao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/28/前端性能优化原理与实践/3存储篇 1：浏览器缓存机制介绍与缓存策略剖析/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-28T19:01:07+08:00">
                2019-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="浏览器缓存机制介绍与缓存策略剖析"><a href="#浏览器缓存机制介绍与缓存策略剖析" class="headerlink" title="浏览器缓存机制介绍与缓存策略剖析"></a>浏览器缓存机制介绍与缓存策略剖析</h1><p>缓存可以减少网络 IO 消耗，提高访问速度。浏览器缓存是一种操作简单、效果显著的前端性能优化手段。对于这个操作的必要性，Chrome 官方给出的解释似乎更有说服力一些： </p>
<blockquote>
<p>通过网络获取内容既速度缓慢又开销巨大。较大的响应需要在客户端与服务器之间进行多次往返通信，这会延迟浏览器获得和处理内容的时间，还会增加访问者的流量费用。因此，缓存并重复利用之前获取的资源的能力成为性能优化的一个关键方面。</p>
</blockquote>
<p>很多时候，大家倾向于将浏览器缓存简单地理解为“HTTP 缓存”。但事实上，浏览器缓存机制有四个方面，它们按照获取资源时请求的优先级依次排列如下：</p>
<ol>
<li>Memory Cache</li>
<li>Service Worker Cache</li>
<li>HTTP Cache</li>
<li>Push Cache</li>
</ol>
<p>大家对 HTTP Cache（即 Cache-Control、expires 等字段控制的缓存）应该比较熟悉，如果对其它几种缓存可能还没什么概念，我们可以先来看一张线上网站的 Network 面板截图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/20/165f714800e5be49?w=2774&h=676&f=png&s=432948" alt></p>
<p>我们给 size 这一栏一个特写：   </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/20/165f715425bd73b6?w=186&h=440&f=png&s=33574" alt></p>
<p>大家注意一下非数字——即形如“（from xxx）”这样的描述——对应的资源，这些资源就是我们通过缓存获取到的。其中，“from memory cache”对标到 Memory Cache 类型，“from ServiceWorker”对标到 Service Worker Cache 类型。至于 Push Cache，这个比较特殊，是 HTTP2 的新特性。    </p>
<p>本节将会针对这四个方面各个击破。考虑到 HTTP 缓存是最主要、最具有代表性的缓存策略，也是每一位前端工程师都应该深刻理解掌握的性能优化知识点，我们下面优先针对 HTTP 缓存机制进行剖析。    </p>
<h2 id="HTTP-缓存机制探秘"><a href="#HTTP-缓存机制探秘" class="headerlink" title="HTTP 缓存机制探秘"></a>HTTP 缓存机制探秘</h2><p>HTTP 缓存是我们日常开发中最为熟悉的一种缓存机制。它又分为<strong>强缓存</strong>和<strong>协商缓存</strong>。优先级较高的是强缓存，在命中强缓存失败的情况下，才会走协商缓存。   </p>
<h3 id="强缓存的特征"><a href="#强缓存的特征" class="headerlink" title="强缓存的特征"></a>强缓存的特征</h3><p>强缓存是利用 http 头中的 Expires 和 Cache-Control 两个字段来控制的。强缓存中，当请求再次发出时，浏览器会根据其中的 expires 和 cache-control 判断目标资源是否“命中”强缓存，若命中则直接从缓存中获取资源，<strong>不会再与服务端发生通信。</strong>  </p>
<p>命中强缓存的情况下，返回的 HTTP 状态码为 200 （如下图）。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/20/165f6a683fc021e1?w=660&h=100&f=png&s=15006" alt></p>
<h3 id="强缓存的实现：从-expires-到-cache-control"><a href="#强缓存的实现：从-expires-到-cache-control" class="headerlink" title="强缓存的实现：从 expires 到 cache-control"></a>强缓存的实现：从 expires 到 cache-control</h3><p>实现强缓存，过去我们一直用 <code>expires</code>。<br>当服务器返回响应时，在 Response Headers 中将过期时间写入 expires 字段。像这样：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/20/165f52bf6e844b85?w=710&h=388&f=png&s=67960" alt></p>
<p>我们给 expires 一个特写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">expires: Wed, <span class="number">11</span> Sep <span class="number">2019</span> <span class="number">16</span>:<span class="number">12</span>:<span class="number">18</span> GMT</span><br><span class="line"><span class="string">``</span><span class="string">`   </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">可以看到，expires 是一个时间戳，接下来如果我们试图再次向服务器请求资源，浏览器就会先对比本地时间和 expires 的时间戳，如果本地时间小于 expires 设定的过期时间，那么就直接去缓存中取这个资源。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">从这样的描述中大家也不难猜测，expires 是有问题的，它最大的问题在于对“本地时间”的依赖。如果服务端和客户端的时间设置可能不同，或者我直接手动去把客户端的时间改掉，那么 expires 将无法达到我们的预期。    </span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">考虑到 expires 的局限性，HTTP1.1 新增了 `</span>Cache-Control<span class="string">` 字段来完成 expires 的任务。   </span></span><br><span class="line"><span class="string">expires 能做的事情，Cache-Control 都能做；expires 完成不了的事情，Cache-Control 也能做。因此，Cache-Control 可以视作是 expires 的**完全替代方案**。在当下的前端实践里，我们继续使用 expires 的唯一目的就是**向下兼容**。   </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">现在我们给 Cache-Control 字段一个特写：</span></span><br></pre></td></tr></table></figure>

<p>cache-control: max-age=31536000</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如大家所见，在 Cache-Control 中，我们通过 `max-age`  来控制资源的有效期。max-age 不是一个时间戳，而是一个时间长度。在本例中，max-age 是 31536000 秒，它意味着该资源在 31536000 秒以内都是有效的，完美地规避了时间戳带来的潜在问题。 </span><br><span class="line"></span><br><span class="line">**Cache-Control 相对于 expires 更加准确，它的优先级也更高。当 Cache-Control 与 expires 同时出现时，我们以 Cache-Control 为准。**    </span><br><span class="line">   </span><br><span class="line">### Cache-Control 应用分析</span><br><span class="line"></span><br><span class="line">Cache-Control 的神通，可不止于这一个小小的 max-age。如下的用法也非常常见：</span><br></pre></td></tr></table></figure>

<p>cache-control: max-age=3600, s-maxage=31536000</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**s-maxage 优先级高于 max-age，两者同时出现时，优先考虑 s-maxage。如果 s-maxage 未过期，则向代理服务器请求其缓存内容。**      </span><br><span class="line">  </span><br><span class="line">这个 s-maxage 不像 max-age 一样为大家所熟知。的确，在项目不是特别大的场景下，max-age 足够用了。但在依赖各种**代理**的大型架构中，我们不得不考虑**代理服务器**的缓存问题。s-maxage 就是用于表示 cache 服务器上（比如 cache CDN）的缓存的有效时间的，并只对 public 缓存有效。   </span><br><span class="line"> </span><br><span class="line">(10.24晚更新。感谢评论区@敖天羽的补充，此处应注意这样一个细节：s-maxage仅在代理服务器中生效，客户端中我们只考虑max-age。)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">那么什么是 public 缓存呢？说到这里，Cache-Control 中有一些适合放在一起理解的知识点，我们集中梳理一下：   </span><br><span class="line">   </span><br><span class="line">#### public 与 private</span><br><span class="line"></span><br><span class="line">public 与 private 是针对资源是否能够被代理服务缓存而存在的一组对立概念。</span><br><span class="line"></span><br><span class="line">如果我们为资源设置了 public，那么它既可以被浏览器缓存，也可以被代理服务器缓存；如果我们设置了 private，则该资源只能被浏览器缓存。private 为**默认值**。但多数情况下，public 并不需要我们手动设置，比如有很多线上网站的 cache-control 是这样的：  </span><br><span class="line"></span><br><span class="line">![](https://user-gold-cdn.xitu.io/2018/9/20/165f6029fc74bbc6?w=756&amp;h=256&amp;f=png&amp;s=40662)</span><br><span class="line"></span><br><span class="line">设置了 s-maxage，没设置 public，那么 CDN 还可以缓存这个资源吗？答案是肯定的。因为明确的缓存信息（例如“max-age”）已表示响应是可以缓存的。</span><br><span class="line"></span><br><span class="line">#### no-store与no-cache</span><br><span class="line"></span><br><span class="line">no-cache 绕开了浏览器：我们为资源设置了 no-cache 后，每一次发起请求都不会再去询问浏览器的缓存情况，而是直接向服务端去确认该资源是否过期（即走我们下文即将讲解的协商缓存的路线）。</span><br><span class="line">  </span><br><span class="line">no-store 比较绝情，顾名思义就是不使用任何缓存策略。在 no-cache 的基础上，它连服务端的缓存确认也绕开了，只允许你直接向服务端发送请求、并下载完整的响应。   </span><br><span class="line">   </span><br><span class="line">### 协商缓存：浏览器与服务器合作之下的缓存策略   </span><br><span class="line"></span><br><span class="line">协商缓存依赖于服务端与浏览器之间的通信。</span><br><span class="line"></span><br><span class="line">协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源。</span><br><span class="line"></span><br><span class="line">如果服务端提示缓存资源未改动（Not Modified），资源会被**重定向**到浏览器缓存，**这种情况下网络请求对应的状态码是 304**（如下图）。</span><br><span class="line"></span><br><span class="line">![](https://user-gold-cdn.xitu.io/2018/9/20/165f6a6d6ffd4cc2?w=710&amp;h=100&amp;f=png&amp;s=15810)</span><br><span class="line"></span><br><span class="line">### 协商缓存的实现：从 Last-Modified 到 Etag  </span><br><span class="line"></span><br><span class="line">Last-Modified 是一个时间戳，如果我们启用了协商缓存，它会在首次请求时随着 Response Headers 返回：</span><br></pre></td></tr></table></figure>

<p>Last-Modified: Fri, 27 Oct 2017 06:35:57 GMT</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">随后我们每次请求时，会带上一个叫 If-Modified-Since 的时间戳字段，它的值正是上一次 response 返回给它的 last-modified 值：</span><br></pre></td></tr></table></figure>

<p>If-Modified-Since: Fri, 27 Oct 2017 06:35:57 GMT</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">服务器接收到这个时间戳后，会比对该时间戳和资源在服务器上的最后修改时间是否一致，从而判断资源是否发生了变化。如果发生了变化，就会返回一个完整的响应内容，并在 Response Headers 中添加新的 Last-Modified 值；否则，返回如上图的 304 响应，Response Headers 不会再添加 Last-Modified 字段。    </span><br><span class="line">   </span><br><span class="line">使用 Last-Modified 存在一些弊端，这其中最常见的就是这样两个场景：</span><br><span class="line"></span><br><span class="line">- 我们编辑了文件，但文件的内容没有改变。服务端并不清楚我们是否真正改变了文件，它仍然通过最后编辑时间进行判断。因此这个资源在再次被请求时，会被当做新资源，进而引发一次完整的响应——不该重新请求的时候，也会重新请求。 </span><br><span class="line"></span><br><span class="line">- 当我们修改文件的速度过快时（比如花了 100ms 完成了改动），由于 If-Modified-Since 只能检查到以秒为最小计量单位的时间差，所以它是感知不到这个改动的——该重新请求的时候，反而没有重新请求了。    </span><br><span class="line">  </span><br><span class="line">这两个场景其实指向了同一个 bug——服务器并没有正确感知文件的变化。为了解决这样的问题，Etag 作为 Last-Modified 的补充出现了。    </span><br><span class="line">  </span><br><span class="line">Etag 是由服务器为每个资源生成的唯一的**标识字符串**，这个标识字符串是基于文件内容编码的，只要文件内容不同，它们对应的 Etag 就是不同的，反之亦然。因此 Etag 能够精准地感知文件的变化。</span><br><span class="line"></span><br><span class="line">Etag 和 Last-Modified 类似，当首次请求时，我们会在响应头里获取到一个最初的标识符字符串，举个🌰，它可以是这样的：</span><br></pre></td></tr></table></figure>

<p>ETag: W/“2a3b-1602480f459”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">那么下一次请求时，请求头里就会带上一个值相同的、名为 if-None-Match 的字符串供服务端比对了：</span><br></pre></td></tr></table></figure>

<p>If-None-Match: W/“2a3b-1602480f459”</p>
<pre><code>
Etag 的生成过程需要服务器额外付出开销，会影响服务端的性能，这是它的弊端。因此启用 Etag 需要我们审时度势。正如我们刚刚所提到的——Etag 并不能替代 Last-Modified，它只能作为 Last-Modified 的补充和强化存在。 
**Etag 在感知文件变化上比 Last-Modified 更加准确，优先级也更高。当 Etag 和 Last-Modified 同时存在时，以 Etag 为准。** 

## HTTP 缓存决策指南

行文至此，当代 HTTP 缓存技术用到的知识点，我们已经从头到尾挖掘了一遍了。那么在面对一个具体的缓存需求时，我们到底该怎么决策呢？  

走到决策建议这一步，我本来想给大家重新画一个流程图。但是画来画去终究不如 Chrome 官方给出的这张清晰、权威：  

![](https://user-gold-cdn.xitu.io/2018/9/20/165f701820fafcf8?w=595&amp;h=600&amp;f=png&amp;s=52763)  

我们现在一起解读一下这张流程图： 

当我们的资源内容不可复用时，直接为 Cache-Control 设置 no-store，拒绝一切形式的缓存；否则考虑是否每次都需要向服务器进行缓存有效确认，如果需要，那么设 Cache-Control 的值为 no-cache；否则考虑该资源是否可以被代理服务器缓存，根据其结果决定是设置为 private 还是 public；然后考虑该资源的过期时间，设置对应的 max-age 和 s-maxage 值；最后，配置协商缓存需要用到的 Etag、Last-Modified 等参数。    

我个人非常推崇这张流程图给出的决策建议，也强烈推荐大家在理解以上知识点的基础上，将这张图保存下来、在日常开发中用用看，它的可行度非常高。   

OK，走到这里，本节最大的一座山已经被大家翻过去了。接下来的内容会相对比较轻松，大家放松心情，我们继续前行！    

## MemoryCache

MemoryCache，是指存在内存中的缓存。从优先级上来说，它是浏览器最先尝试去命中的一种缓存。从效率上来说，它是响应速度最快的一种缓存。   

内存缓存是快的，也是“短命”的。它和渲染进程“生死相依”，当进程结束后，也就是 tab 关闭以后，内存里的数据也将不复存在。

那么哪些文件会被放入内存呢？  

事实上，这个划分规则，一直以来是没有定论的。不过想想也可以理解，内存是有限的，很多时候需要先考虑即时呈现的内存余量，再根据具体的情况决定分配给内存和磁盘的资源量的比重——资源存放的位置具有一定的随机性。    

虽然划分规则没有定论，但根据日常开发中观察的结果，包括我们开篇给大家展示的 Network 截图，我们至少可以总结出这样的规律：资源存不存内存，浏览器秉承的是“节约原则”。我们发现，Base64 格式的图片，几乎永远可以被塞进 memory cache，这可以视作浏览器为节省渲染开销的“自保行为”；此外，体积不大的 JS、CSS 文件，也有较大地被写入内存的几率——相比之下，较大的 JS、CSS 文件就没有这个待遇了，内存资源是有限的，它们往往被直接甩进磁盘。   

## Service Worker Cache

Service Worker 是一种独立于主线程之外的 Javascript 线程。它脱离于浏览器窗体，因此无法直接访问 DOM。这样独立的个性使得 Service Worker 的“个人行为”无法干扰页面的性能，这个“幕后工作者”可以帮我们实现离线缓存、消息推送和网络代理等功能。我们借助 Service worker 实现的离线缓存就称为 Service Worker Cache。

Service Worker 的生命周期包括 install、active、working 三个阶段。一旦 Service Worker 被 install，它将始终存在，只会在 active 与 working 之间切换，除非我们主动终止它。这是它可以用来实现离线存储的重要先决条件。 

下面我们就通过实战的方式，一起见识一下 Service Worker 如何为我们实现离线缓存（注意看注释）： 
我们首先在入口文件中插入这样一段 JS 代码，用以判断和引入 Service Worker：

```javascript
window.navigator.serviceWorker.register(&apos;/test.js&apos;).then(
   function () {
      console.log(&apos;注册成功&apos;)
    }).catch(err =&gt; {
      console.error(&quot;注册失败&quot;)
    })</code></pre><p>在 test.js 中，我们进行缓存的处理。假设我们需要缓存的文件分别是 test.html,test.css 和 test.js： </p>
<pre><code class="javascript"><span class="comment">// Service Worker会监听 install事件，我们在其对应的回调里可以实现初始化的逻辑  </span>
self.addEventListener(<span class="string">'install'</span>, event =&gt; {
  event.waitUntil(
    <span class="comment">// 考虑到缓存也需要更新，open内传入的参数为缓存的版本号</span>
    caches.open(<span class="string">'test-v1'</span>).then(<span class="function"><span class="params">cache</span> =&gt;</span> {
      <span class="keyword">return</span> cache.addAll([
        <span class="comment">// 此处传入指定的需缓存的文件名</span>
        <span class="string">'/test.html'</span>,
        <span class="string">'/test.css'</span>,
        <span class="string">'/test.js'</span>
      ])
    })
  )
})

<span class="comment">// Service Worker会监听所有的网络请求，网络请求的产生触发的是fetch事件，我们可以在其对应的监听函数中实现对请求的拦截，进而判断是否有对应到该请求的缓存，实现从Service Worker中取到缓存的目的</span>
self.addEventListener(<span class="string">'fetch'</span>, event =&gt; {
  event.respondWith(
    <span class="comment">// 尝试匹配该请求对应的缓存值</span>
    caches.match(event.request).then(<span class="function"><span class="params">res</span> =&gt;</span> {
      <span class="comment">// 如果匹配到了，调用Server Worker缓存</span>
      <span class="keyword">if</span> (res) {
        <span class="keyword">return</span> res;
      }
      <span class="comment">// 如果没匹配到，向服务端发起这个资源请求</span>
      <span class="keyword">return</span> fetch(event.request).then(<span class="function"><span class="params">response</span> =&gt;</span> {
        <span class="keyword">if</span> (!response || response.status !== <span class="number">200</span>) {
          <span class="keyword">return</span> response;
        }
        <span class="comment">// 请求成功的话，将请求缓存起来。</span>
        caches.open(<span class="string">'test-v1'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>{
          cache.put(event.request, response);
        });
        <span class="keyword">return</span> response.clone();
      });
    })
  );
});</code></pre>
<p><strong>PS</strong>：大家注意 Server Worker 对协议是有要求的，必须以 https 协议为前提。   </p>
<h2 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h2><blockquote>
<p>预告：本小节定位为基础科普向，对 Push Cache 有深入挖掘兴趣的同学，强烈推荐拓展阅读 Chrome 工程师 Jake Archibald 的这篇 <a href="https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/" target="_blank" rel="noopener">HTTP/2 push is tougher than I thought</a>。   </p>
</blockquote>
<p>Push Cache 是指 HTTP2 在 server push 阶段存在的缓存。这块的知识比较新，应用也还处于萌芽阶段，我找了好几个网站也没找到一个合适的案例来给大家做具体的介绍。但应用范围有限不代表不重要——HTTP2 是趋势、是未来。在它还未被推而广之的此时此刻，我仍希望大家能对 Push Cache 的关键特性有所了解：</p>
<ul>
<li>Push Cache 是缓存的最后一道防线。浏览器只有在 Memory Cache、HTTP Cache 和 Service Worker Cache 均未命中的情况下才会去询问 Push Cache。   </li>
<li>Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。   </li>
<li>不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache。  </li>
</ul>
<p>更多的特性和应用，期待大家可以在日后的开发过程中去挖掘和实践。   </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>小建议！很多同学在学习缓存这块知识的时候可能多少会有这样的感觉：对浏览器缓存，只能描述个大致，却说不上深层原理；好不容易记住了每个字段怎么用，过几天又给忘了。这是因为缓存部分的知识，具有“细碎、迭代快”的特点。对于这样的知识，我们应该尝试先划分出层次和重点，归纳出完整的体系，然后针对每个知识点去各个击破。   </p>
<p>终于结束了对缓存世界的探索，不知道大家有没有一种意犹未尽的感觉。开篇我们谈过，缓存非常重要，它几乎是我们性能优化的首选方案。</p>
<p>但页面的数据存储方案除了缓存，还有本地存储。在下一节中，我们就将围绕本地存储展开探索。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/28/前端性能优化原理与实践/10渲染篇 5：最后一击——回流（Reflow）与重绘（Repaint）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qicainiao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qicainiao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/28/前端性能优化原理与实践/10渲染篇 5：最后一击——回流（Reflow）与重绘（Repaint）/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-28T19:01:07+08:00">
                2019-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="最后一击——回流（Reflow）与重绘（Repaint）"><a href="#最后一击——回流（Reflow）与重绘（Repaint）" class="headerlink" title="最后一击——回流（Reflow）与重绘（Repaint）"></a>最后一击——回流（Reflow）与重绘（Repaint）</h1><p>开篇我们先对上上节介绍的回流与重绘的基础知识做个复习（跳读的同学请自觉回到上上节补齐 →_→）。    </p>
<p><strong>回流</strong>：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。</p>
<p><strong>重绘</strong>：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。这个过程叫做重绘。</p>
<p>由此我们可以看出，<strong>重绘不一定导致回流，回流一定会导致重绘</strong>。硬要比较的话，回流比重绘做的事情更多，带来的开销也更大。但这两个说到底都是吃性能的，所以都不是什么善茬。我们在开发中，要从代码层面出发，尽可能把回流和重绘的次数最小化。    </p>
<h2 id="哪些实际操作会导致回流与重绘"><a href="#哪些实际操作会导致回流与重绘" class="headerlink" title="哪些实际操作会导致回流与重绘"></a>哪些实际操作会导致回流与重绘</h2><p>要避免回流与重绘的发生，最直接的做法是避免掉可能会引发回流与重绘的 DOM 操作，就好像拆弹专家在解决一颗炸弹时，最重要的是掐灭它的导火索。</p>
<p>触发重绘的“导火索”比较好识别——只要是不触发回流，但又触发了样式改变的 DOM 操作，都会引起重绘，比如背景色、文字色、可见性(可见性这里特指形如visibility: hidden这样不改变元素位置和存在性的、单纯针对可见性的操作，注意与display:none进行区分)等。为此，我们要着重理解一下那些可能触发回流的操作。</p>
<h3 id="回流的“导火索”"><a href="#回流的“导火索”" class="headerlink" title="回流的“导火索”"></a>回流的“导火索”</h3><ul>
<li>最“贵”的操作：改变 DOM 元素的几何属性</li>
</ul>
<p>这个改变几乎可以说是“牵一发动全身”——当一个DOM元素的几何属性发生变化时，所有和它相关的节点（比如父子节点、兄弟节点等）的几何属性都需要进行重新计算，它会带来巨大的计算量。</p>
<p>常见的几何属性有 width、height、padding、margin、left、top、border 等等。此处不再给大家一一列举。有的文章喜欢罗列属性表格，但我相信我今天列出来大家也不会看、看了也记不住（因为太多了）。我自己也不会去记这些——其实确实没必要记，️一个属性是不是几何属性、会不会导致空间布局发生变化，大家写样式的时候完全可以通过代码效果看出来。多说无益，还希望大家可以多写多试，形成自己的“肌肉记忆”。</p>
<ul>
<li>“价格适中”的操作：改变 DOM 树的结构 </li>
</ul>
<p>这里主要指的是节点的增减、移动等操作。浏览器引擎布局的过程，顺序上可以类比于树的前序遍历——它是一个从上到下、从左到右的过程。通常在这个过程中，当前元素不会再影响其前面已经遍历过的元素。    </p>
<ul>
<li>最容易被忽略的操作：获取一些特定属性的值   </li>
</ul>
<p>当你要用到像这样的属性：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight 时，你就要注意了！</p>
<p>“像这样”的属性，到底是像什么样？——这些值有一个共性，就是需要通过<strong>即时计算</strong>得到。因此浏览器为了获取这些值，也会进行回流。  </p>
<p>除此之外，当我们调用了 getComputedStyle 方法，或者 IE 里的 currentStyle 时，也会触发回流。原理是一样的，都为求一个“即时性”和“准确性”。</p>
<h2 id="如何规避回流与重绘"><a href="#如何规避回流与重绘" class="headerlink" title="如何规避回流与重绘"></a>如何规避回流与重绘</h2><p>了解了回流与重绘的“导火索”，我们就要尽量规避它们。但很多时候，我们不得不使用它们。当避无可避时，我们就要学会更聪明地使用它们。 </p>
<h3 id="将“导火索”缓存起来，避免频繁改动"><a href="#将“导火索”缓存起来，避免频繁改动" class="headerlink" title="将“导火索”缓存起来，避免频繁改动"></a>将“导火索”缓存起来，避免频繁改动</h3><p>有时我们想要通过多次计算得到一个元素的布局位置，我们可能会这样做： </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    #el &#123;</span><br><span class="line">      width: 100px;</span><br><span class="line">      height: 100px;</span><br><span class="line">      background-color: yellow;</span><br><span class="line">      position: absolute;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"el"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 获取el元素</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'el'</span>)</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 这里循环判定比较简单，实际中或许会拓展出比较复杂的判定需求</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span></span><br><span class="line"><span class="javascript">      el.style.top  = el.offsetTop  + <span class="number">10</span> + <span class="string">"px"</span>;</span></span><br><span class="line"><span class="javascript">      el.style.left = el.offsetLeft + <span class="number">10</span> + <span class="string">"px"</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样做，每次循环都需要获取多次“敏感属性”，是比较糟糕的。我们可以将其以 JS 变量的形式缓存起来，待计算完毕再提交给浏览器发出重计算请求：   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存offsetLeft与offsetTop的值</span></span><br><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'el'</span>) </span><br><span class="line"><span class="keyword">let</span> offLeft = el.offsetLeft, offTop = el.offsetTop</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在JS层面进行计算</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">  offLeft += <span class="number">10</span></span><br><span class="line">  offTop  += <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次性将计算结果应用到DOM上</span></span><br><span class="line">el.style.left = offLeft + <span class="string">"px"</span></span><br><span class="line">el.style.top = offTop  + <span class="string">"px"</span></span><br><span class="line"><span class="string">``</span><span class="string">`   </span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">### 避免逐条改变样式，使用类名去合并样式</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">比如我们可以把这段单纯的代码：   </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line">container.style.width = <span class="string">'100px'</span></span><br><span class="line">container.style.height = <span class="string">'200px'</span></span><br><span class="line">container.style.border = <span class="string">'10px solid red'</span></span><br><span class="line">container.style.color = <span class="string">'red'</span></span><br></pre></td></tr></table></figure>

<p>优化成一个有 class 加持的样子：   </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    .basic_style &#123;</span><br><span class="line">      width: 100px;</span><br><span class="line">      height: 200px;</span><br><span class="line">      border: 10px solid red;</span><br><span class="line">      color: red;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span></span><br><span class="line"><span class="javascript">  container.classList.add(<span class="string">'basic_style'</span>)</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>前者每次单独操作，都去触发一次渲染树更改，从而导致相应的回流与重绘过程。</p>
<p>合并之后，等于我们将所有的更改一次性发出，用一个 style 请求解决掉了。   </p>
<h3 id="将-DOM-“离线”"><a href="#将-DOM-“离线”" class="headerlink" title="将 DOM “离线”"></a>将 DOM “离线”</h3><p>我们上文所说的回流和重绘，都是在“该元素位于页面上”的前提下会发生的。一旦我们给元素设置 display: none，将其从页面上“拿掉”，那么我们的后续操作，将无法触发回流与重绘——这个将元素“拿掉”的操作，就叫做 DOM 离线化。</p>
<p>仍以我们上文的代码片段为例： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line">container.style.width = <span class="string">'100px'</span></span><br><span class="line">container.style.height = <span class="string">'200px'</span></span><br><span class="line">container.style.border = <span class="string">'10px solid red'</span></span><br><span class="line">container.style.color = <span class="string">'red'</span></span><br><span class="line">...（省略了许多类似的后续操作）</span><br></pre></td></tr></table></figure>

<p>离线化后就是这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line">container.style.display = <span class="string">'none'</span></span><br><span class="line">container.style.width = <span class="string">'100px'</span></span><br><span class="line">container.style.height = <span class="string">'200px'</span></span><br><span class="line">container.style.border = <span class="string">'10px solid red'</span></span><br><span class="line">container.style.color = <span class="string">'red'</span></span><br><span class="line">...（省略了许多类似的后续操作）</span><br><span class="line">container.style.display = <span class="string">'block'</span></span><br></pre></td></tr></table></figure>

<p>有的同学会问，拿掉一个元素再把它放回去，这不也会触发一次昂贵的回流吗？这话不假，但我们把它拿下来了，后续不管我操作这个元素多少次，每一步的操作成本都会非常低。当我们只需要进行很少的 DOM 操作时，DOM 离线化的优越性确实不太明显。一旦操作频繁起来，这“拿掉”和“放回”的开销都将会是非常值得的。   </p>
<h2 id="Flush-队列：浏览器并没有那么简单"><a href="#Flush-队列：浏览器并没有那么简单" class="headerlink" title="Flush 队列：浏览器并没有那么简单"></a>Flush 队列：浏览器并没有那么简单</h2><p>以我们现在的知识基础，理解上面的优化操作并不难。那么现在我问大家一个问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line">container.style.width = <span class="string">'100px'</span></span><br><span class="line">container.style.height = <span class="string">'200px'</span></span><br><span class="line">container.style.border = <span class="string">'10px solid red'</span></span><br><span class="line">container.style.color = <span class="string">'red'</span></span><br></pre></td></tr></table></figure>

<p>这段代码里，浏览器进行了多少次的回流或重绘呢？ </p>
<p>“width、height、border是几何属性，各触发一次回流；color只造成外观的变化，会触发一次重绘。”——如果你立刻这么想了，说明你是个能力不错的同学，认真阅读了前面的内容。那么我们现在立刻跑一跑这段代码，看看浏览器怎么说：   </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/4/1663f57519a785ab?w=1284&h=96&f=png&s=18506" alt>   </p>
<p>这里为大家截取有“Layout”和“Paint”出镜的片段（这个图是通过 Chrome 的 Performance 面板得到的，后面会教大家用这个东西）。我们看到浏览器只进行了一次回流和一次重绘——和我们想的不一样啊，为啥呢？      </p>
<p>因为现代浏览器是很聪明的。浏览器自己也清楚，如果每次 DOM 操作都即时地反馈一次回流或重绘，那么性能上来说是扛不住的。于是它自己缓存了一个 flush 队列，把我们触发的回流与重绘任务都塞进去，待到队列里的任务多起来、或者达到了一定的时间间隔，或者“不得已”的时候，再将这些任务一口气出队。因此我们看到，上面就算我们进行了 4 次 DOM 更改，也只触发了一次 Layout 和一次 Paint。   </p>
<p>大家这里尤其小心这个“不得已”的时候。前面我们在介绍回流的“导火索”的时候，提到过有一类属性很特别，它们有很强的“即时性”。当我们访问这些属性时，浏览器会为了获得此时此刻的、最准确的属性值，而提前将 flush 队列的任务出队——这就是所谓的“不得已”时刻。具体是哪些属性值，我们已经在“最容易被忽略的操作”这个小模块介绍过了，此处不再赘述。    </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>整个一节读下来，可能会有同学感到疑惑：既然浏览器已经为我们做了批处理优化，为什么我们还要自己操心这么多事情呢？今天避免这个明天避免那个，多麻烦！   </p>
<p>问题在于，<strong>并不是所有的浏览器都是聪明的</strong>。我们刚刚的性能图表，是 Chrome 的开发者工具呈现给我们的。Chrome 里行得通的东西，到了别处（比如 IE）就不一定行得通了。而我们并不知道用户会使用什么样的浏览器。如果不手动做优化，那么一个页面在不同的环境下就会呈现不同的性能效果，这对我们、对用户都是不利的。因此，养成良好的编码习惯、从根源上解决问题，仍然是最周全的方法。       </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/28/前端性能优化原理与实践/5彩蛋篇：CDN 的缓存与回源机制解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qicainiao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qicainiao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/28/前端性能优化原理与实践/5彩蛋篇：CDN 的缓存与回源机制解析/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-28T19:01:07+08:00">
                2019-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="CDN-的缓存与回源机制解析"><a href="#CDN-的缓存与回源机制解析" class="headerlink" title="CDN 的缓存与回源机制解析"></a>CDN 的缓存与回源机制解析</h1><h2 id="写在小册的半山腰"><a href="#写在小册的半山腰" class="headerlink" title="写在小册的半山腰"></a>写在小册的半山腰</h2><p>不知不觉，小册内容已经过了小半了。</p>
<p>回顾一下走过的路：在对知识体系进行一番梳理后，我们操起 webpack 开始优化文件（顺便还学了点 Gzip），随后又马不停蹄进入图片的小天地，最后把缓存和本地存储的味道逐一品尝，终于得以窥见网络层面核心优化技术的全貌。</p>
<p>古人云：学而不思则罔。</p>
<p>站在性能优化的半山腰，我希望大家可以缓一缓，停下来思考一个问题：我得到了什么？   </p>
<p>作为作者，我在自己写的每一行字背后都费了思量。在过去的每个章节里我都预先为知识点做了权重划分，力求“详略得当”，而非盲目地求大求全。孰详孰略，只能根据知识点本身的重要性来划分，但读者的知识结构是多样的。“如何使阅读效益最大化”的金钥匙不在我手中，而是在各位自己手中。</p>
<p>本小册中我有所提及的每一个知识点，<strong>都有大公司在实践</strong>。即便是略写的内容，大家也值得进一步去推敲。可以尝试深挖这本小册的可能性，把它用起来，用到自己的工作中去，去看看它能否给你的业务带来提升，看看是否还有更精进的方案。      </p>
<p>我是一个“啰嗦”的人。尤其是意识到这本书可能会成为一些同学的性能优化启蒙读物时，我更加认为有必要在行文小半时再啰嗦这么一遍：如果读到这里，脑海中无法复现出网络层面的知识体系，无法在回忆每个技术点时记起它的场景和特性，我建议不要急于往下走，而是回过头去再看看学过的这部分的内容——走马观花不是学习，主动理解+动手实践才是。       </p>
<h2 id="彩蛋：CDN的缓存与回源机制解析"><a href="#彩蛋：CDN的缓存与回源机制解析" class="headerlink" title="彩蛋：CDN的缓存与回源机制解析"></a>彩蛋：CDN的缓存与回源机制解析</h2><blockquote>
<p>CDN （Content Delivery Network，即内容分发网络）指的是一组分布在各个地区的服务器。这些服务器存储着数据的副本，因此服务器可以根据哪些服务器与用户距离最近，来满足数据的请求。 CDN 提供快速服务，较少受高流量影响。</p>
</blockquote>
<h3 id="为什么要用-CDN"><a href="#为什么要用-CDN" class="headerlink" title="为什么要用 CDN"></a>为什么要用 CDN</h3><p>浏览器存储的相关知识此刻离我们还不太远，大家趁热回忆一下：缓存、本地存储带来的性能提升，是不是只能在“获取到资源并把它们存起来”这件事情发生之后？也就是说，首次请求资源的时候，这些招数都是救不了我们的。要提升首次请求的响应能力，除了我们 2、3、4 节提到的方案之外，我们还需要借助 CDN 的能力。</p>
<h3 id="CDN-如何工作"><a href="#CDN-如何工作" class="headerlink" title="CDN 如何工作"></a>CDN 如何工作</h3><p>借中国地图一角来给大家举一个简单的🌰： </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/23/16605c1a4961f07e?w=1184&h=1020&f=png&s=1191786" alt> </p>
<p>假设我的根服务器在杭州，同时在图示的五个城市里都有自己可用的机房。   </p>
<p>此时有一位北京的用户向我请求资源。在网络带宽小、用户访问量大的情况下，杭州的这一台服务器或许不那么给力，不能给用户非常快的响应速度。于是我灵机一动，把这批资源 copy 了一批放在北京的机房里。当用户请求资源时，就近请求北京的服务器，北京这台服务器低头一看，这个资源我存了，离得这么近，响应速度肯定噌噌的！那如果北京这台服务器没有 copy 这批资源呢？它会再向杭州的根服务器去要这个资源。在这个过程中，北京这台服务器就扮演着 CDN 的角色。       </p>
<h3 id="CDN的核心功能特写"><a href="#CDN的核心功能特写" class="headerlink" title="CDN的核心功能特写"></a>CDN的核心功能特写</h3><p>CDN 的核心点有两个，一个是<strong>缓存</strong>，一个是<strong>回源</strong>。   </p>
<p>这两个概念都非常好理解。对标到上面描述的过程，“缓存”就是说我们把资源 copy 一份到 CDN 服务器上这个过程，“回源”就是说 CDN 发现自己没有这个资源（一般是缓存的数据过期了），转头向根服务器（或者它的上层服务器）去要这个资源的过程。     </p>
<h3 id="CDN-与前端性能优化"><a href="#CDN-与前端性能优化" class="headerlink" title="CDN 与前端性能优化"></a>CDN 与前端性能优化</h3><p>一个彩蛋的自我修养——CDN 往往是被前端认为前端不需要了解的东西。    </p>
<p>具体来说，我身边许多同学对其的了解止步于：部署界面上有一个“部署到CDN”按钮，我去点一下，资源就在 CDN 上啦！   </p>
<p>“眼下业务开发用不到的可以暂缓了解”，这是没毛病的。但正如我小册开篇所说的，前端工程师首先是软件工程师。对整个技术架构的理解，将会反哺我们对某一具体环节的理解；知识点的适当拓展，也会对大家技术高度和技术广度的提升大有裨益。   </p>
<p>那么，我们了解一下 CDN 是怎么帮助前端的。</p>
<p><strong>CDN 往往被用来存放静态资源</strong>。上文中我们举例所提到的“根服务器”本质上是业务服务器，它的核心任务在于<strong>生成动态页面或返回非纯静态页面</strong>，这两种过程都是需要计算的。业务服务器仿佛一个车间，车间里运转的机器轰鸣着为我们产出所需的资源；相比之下，CDN 服务器则像一个仓库，它只充当资源的“栖息地”和“搬运工”。      </p>
<p>所谓“静态资源”，就是像 JS、CSS、图片等<strong>不需要业务服务器进行计算即得的资源</strong>。而“动态资源”，顾名思义是需要<strong>后端实时动态生成的资源</strong>，较为常见的就是 JSP、ASP 或者依赖服务端渲染得到的 HTML 页面。</p>
<p>什么是“非纯静态资源”呢？它是指<strong>需要服务器在页面之外作额外计算的 HTML 页面</strong>。具体来说，当我打开某一网站之前，该网站需要通过权限认证等一系列手段确认我的身份、进而决定是否要把 HTML 页面呈现给我。这种情况下 HTML 确实是静态的，但它<strong>和业务服务器的操作耦合</strong>，我们把它丢到CDN 上显然是不合适的。    </p>
<h3 id="CDN-的实际应用"><a href="#CDN-的实际应用" class="headerlink" title="CDN 的实际应用"></a>CDN 的实际应用</h3><p>静态资源本身具有访问频率高、承接流量大的特点，因此静态资源加载速度始终是前端性能的一个非常关键的指标。CDN 是静态资源提速的重要手段，在许多一线的互联网公司，“静态资源走 CDN”并不是一个建议，而是一个规定。</p>
<p>比如以淘宝为代表的阿里系产品，就遵循着这个“规定”。<br>打开淘宝首页，我们可以在 Network 面板中看到，“非纯静态”的 HTML 页面，是向业务服务器请求来的：  </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/25/1660f50337974e82?w=1118&h=678&f=png&s=236400" alt>  </p>
<p>我们点击 preview，可以看到业务服务器确实是返回给了我们一个尚未被静态资源加持过的简单 HTML 页面，所有的图片内容都是先以一个 div 占位：   </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/25/1660f52fe65facba?w=2102&h=1150&f=png&s=64675" alt>   </p>
<p>相应地，我们随便点开一个静态资源，可以看到它都是从 CDN 服务器上请求来的。</p>
<p>比如说图片：   </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/25/1660f555fb76a89a?w=1124&h=106&f=png&s=26307" alt>   </p>
<p>再比如 JS、CSS 文件：   </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/25/1660f57436da98f0?w=1606&h=134&f=png&s=43046" alt>     </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/25/1660f57b6b995d5e?w=1708&h=150&f=png&s=56740" alt>    </p>
<h3 id="CDN-优化细节"><a href="#CDN-优化细节" class="headerlink" title="CDN 优化细节"></a>CDN 优化细节</h3><p>如何让 CDN 的效用最大化？这又是需要前后端程序员一起思考的庞大命题。它涉及到 CDN 服务器本身的性能优化、CDN 节点的地址选取等。但我们今天不写高深的论文，只谈离前端最近的这部分细节：CDN 的域名选取。</p>
<p>大家先回头看一下我刚刚选取的淘宝首页的例子，我们注意到业务服务器的域名是这个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.taobao.com</span><br></pre></td></tr></table></figure>

<p>而 CDN 服务器的域名是这个：</p>
<pre><code>g.alicdn.com</code></pre><p>没错，我们不一样！</p>
<p>再看另一方面，我们讲到 Cookie 的时候，为了凸显 Local Storage 的优越性，曾经提到过：</p>
<blockquote>
<p>Cookie 是紧跟域名的。同一个域名下的所有请求，都会携带 Cookie。大家试想，如果我们此刻仅仅是请求一张图片或者一个 CSS 文件，我们也要携带一个 Cookie 跑来跑去（关键是 Cookie 里存储的信息我现在并不需要），这是一件多么劳民伤财的事情。Cookie 虽然小，请求却可以有很多，随着请求的叠加，这样的不必要的 Cookie 带来的开销将是无法想象的……</p>
</blockquote>
<p>同一个域名下的请求会不分青红皂白地携带 Cookie，而静态资源往往并不需要 Cookie 携带什么认证信息。把静态资源和主页面置于不同的域名下，完美地避免了不必要的 Cookie 的出现！</p>
<p>看起来是一个不起眼的小细节，但带来的效用却是惊人的。以电商网站静态资源的流量之庞大，如果没把这个多余的 Cookie 拿下来，不仅用户体验会大打折扣，每年因性能浪费带来的经济开销也将是一个非常恐怖的数字。   </p>
<p>如此看来，性能优化还真是要步步为营！    </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>结束了对 CDN 的剖析，我们网络层面的优化之旅也终于告一段落了。接下来等待大家的就是另一个庞大的知识板块——渲染层面的挑战。    </p>
<p>与其说是“渲染层面的优化”，不如说是“浏览器端的优化”。这个板块旨在要大家对浏览器及其相关运行机制“知根知底”，进而通过具体的代码片段学习代码层面的应用手段。这部分是实打实的“硬骨头”，需要大家花些精力。</p>
<p>过去的几个小节里，我们考虑了服务端，考虑了网络，考虑了协议。那么接下来，我们就以“服务端渲染”为引子，承上启下，切入浏览器渲染的世界。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/28/前端性能优化原理与实践/7渲染篇 2：知己知彼——解锁浏览器背后的运行机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qicainiao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qicainiao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/28/前端性能优化原理与实践/7渲染篇 2：知己知彼——解锁浏览器背后的运行机制/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-28T19:01:07+08:00">
                2019-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="知己知彼——解锁浏览器背后的运行机制"><a href="#知己知彼——解锁浏览器背后的运行机制" class="headerlink" title="知己知彼——解锁浏览器背后的运行机制"></a>知己知彼——解锁浏览器背后的运行机制</h1><p>从本章开始，我们的性能优化探险也正式进入到了“深水区”——浏览器端的性能优化。    </p>
<p>平时我们几乎每天都在和浏览器打交道，在一些兼容任务比较繁重的团队里，苦逼的前端攻城师们甚至为了兼容各个浏览器而不断地去测试和调试，还要在脑子中记下各种遇到的 BUG 及解决方案。即便如此，我们好像并没有去主动地关注和了解下浏览器的工作原理。我想如果我们对此做一点了解，在项目过程中就可以有效地避免一些问题，并对页面性能做出相应的改进。</p>
<p>“知己知彼，百战不殆”，今天，我们就一起来揭开浏览器渲染过程的神秘面纱！    </p>
<h2 id="浏览器的“心”"><a href="#浏览器的“心”" class="headerlink" title="浏览器的“心”"></a>浏览器的“心”</h2><p>浏览器的“心”，说的就是浏览器的内核。在研究浏览器微观的运行机制之前，我们首先要对浏览器内核有一个宏观的把握。      </p>
<p>开篇我提到许多工程师因为业务需要，免不了需要去处理不同浏览器下代码渲染结果的差异性。这些差异性正是因为浏览器内核的不同而导致的——浏览器内核决定了浏览器解释网页语法的方式。<br>浏览器内核可以分成两部分：渲染引擎（Layout Engine 或者 Rendering Engine）和 JS 引擎。早期渲染引擎和 JS 引擎并没有十分明确的区分，但随着 JS 引擎越来越独立，内核也成了渲染引擎的代称（<strong>下文我们将沿用这种叫法</strong>）。渲染引擎又包括了 HTML 解释器、CSS 解释器、布局、网络、存储、图形、音视频、图片解码器等等零部件。    </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619bf6505a94db?w=1042&h=282&f=png&s=367791" alt></p>
<p>目前市面上常见的浏览器内核可以分为这四种：Trident（IE）、Gecko（火狐）、Blink（Chrome、Opera）、Webkit（Safari）。</p>
<p>这里面大家最耳熟能详的可能就是 Webkit 内核了。很多同学可能会听说过 Chrome 的内核就是 Webkit，殊不知 Chrome 内核早已迭代为了 Blink。但是换汤不换药，Blink 其实也是基于 Webkit 衍生而来的一个分支，因此，Webkit 内核仍然是当下浏览器世界真正的霸主。</p>
<p>下面我们就以 Webkit 为例，对现代浏览器的渲染过程进行一个深度的剖析。</p>
<h2 id="开启浏览器渲染“黑盒”"><a href="#开启浏览器渲染“黑盒”" class="headerlink" title="开启浏览器渲染“黑盒”"></a>开启浏览器渲染“黑盒”</h2><p>什么是渲染过程？简单来说，渲染引擎根据 HTML 文件描述构建相应的数学模型，调用浏览器各个零部件，从而将网页资源代码转换为图像结果，这个过程就是渲染过程（如下图）。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16618c7f0cb0768a?w=675&h=122&f=png&s=6464" alt></p>
<p>从这个流程来看，浏览器呈现网页这个过程，宛如一个黑盒。在这个神秘的黑盒中，有许多功能模块，内核内部的实现正是这些功能模块相互配合协同工作进行的。其中我们最需要关注的，就是<strong>HTML 解释器</strong>、<strong>CSS 解释器</strong>、<strong>图层布局计算模块</strong>、<strong>视图绘制模块</strong>与<strong>JavaScript 引擎</strong>这几大模块：</p>
<ul>
<li><p>HTML 解释器：将 HTML 文档经过词法分析输出 DOM 树。</p>
</li>
<li><p>CSS 解释器：解析 CSS 文档, 生成样式规则。</p>
</li>
<li><p>图层布局计算模块：布局计算每个对象的精确位置和大小。</p>
</li>
<li><p>视图绘制模块：进行具体节点的图像绘制，将像素渲染到屏幕上。</p>
</li>
<li><p>JavaScript 引擎：编译执行 Javascript 代码。</p>
</li>
</ul>
<h2 id="浏览器渲染过程解析"><a href="#浏览器渲染过程解析" class="headerlink" title="浏览器渲染过程解析"></a>浏览器渲染过程解析</h2><p>有了对零部件的了解打底，我们就可以一起来走一遍浏览器的渲染流程了。在浏览器里，每一个页面的首次渲染都经历了如下阶段（图中箭头不代表串行，有一些操作是并行进行的，下文会说明）：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16618c829b879f35?w=1858&h=464&f=png&s=94133" alt></p>
<ul>
<li><strong>解析 HTML</strong></li>
</ul>
<p>在这一步浏览器执行了所有的加载解析逻辑，在解析 HTML 的过程中发出了页面渲染所需的各种外部资源请求。   </p>
<ul>
<li><strong>计算样式</strong></li>
</ul>
<p>浏览器将识别并加载所有的 CSS 样式信息与 DOM 树合并，最终生成页面 render 树（:after :before 这样的伪元素会在这个环节被构建到 DOM 树中）。</p>
<ul>
<li><strong>计算图层布局</strong></li>
</ul>
<p>页面中所有元素的相对位置信息，大小等信息均在这一步得到计算。</p>
<ul>
<li><strong>绘制图层</strong></li>
</ul>
<p>在这一步中浏览器会根据我们的 DOM 代码结果，把每一个页面图层转换为像素，并对所有的媒体文件进行解码。</p>
<ul>
<li><strong>整合图层，得到页面</strong></li>
</ul>
<p>最后一步浏览器会合并合各个图层，将数据由 CPU 输出给 GPU 最终绘制在屏幕上。（复杂的视图层会给这个阶段的 GPU 计算带来一些压力，在实际应用中为了优化动画性能，我们有时会手动区分不同的图层）。</p>
<h2 id="几棵重要的“树”"><a href="#几棵重要的“树”" class="headerlink" title="几棵重要的“树”"></a>几棵重要的“树”</h2><p>上面的内容没有理解透彻？别着急，我们一起来捋一捋这个过程中的重点——树！</p>
<p>为了使渲染过程更明晰一些，我们需要给这些”树“们一个特写:   </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/27/16619d637d220b20?w=1018&h=377&f=png&s=45067" alt></p>
<ul>
<li><p>DOM 树：解析 HTML 以创建的是 DOM 树（DOM tree ）：渲染引擎开始解析 HTML 文档，转换树中的标签到 DOM 节点，它被称为“内容树”。</p>
</li>
<li><p>CSSOM 树：解析 CSS（包括外部 CSS 文件和样式元素）创建的是 CSSOM 树。CSSOM 的解析过程与 DOM 的解析过程是<strong>并行的</strong>。</p>
</li>
<li><p>渲染树：CSSOM 与 DOM 结合，之后我们得到的就是渲染树（Render tree ）。</p>
</li>
<li><p>布局渲染树：从根节点递归调用，计算每一个元素的大小、位置等，给每个节点所应该出现在屏幕上的精确坐标，我们便得到了基于渲染树的布局渲染树（Layout of the render tree）。</p>
</li>
<li><p>绘制渲染树: 遍历渲染树，每个节点将使用 UI 后端层来绘制。整个过程叫做绘制渲染树（Painting the render tree）。</p>
</li>
</ul>
<p>基于这些“树”，我们再梳理一番： </p>
<p>渲染过程说白了，首先是基于 HTML 构建一个 DOM 树，这棵 DOM 树与 CSS 解释器解析出的 CSSOM 相结合，就有了布局渲染树。最后浏览器以布局渲染树为蓝本，去计算布局并绘制图像，我们页面的初次渲染就大功告成了。</p>
<p>之后每当一个新元素加入到这个 DOM 树当中，浏览器便会通过 CSS 引擎查遍 CSS 样式表，找到符合该元素的样式规则应用到这个元素上，然后再重新去绘制它。    </p>
<p>有心的同学可能已经在思考了，查表是个花时间的活，我怎么让浏览器的查询工作又快又好地实现呢？OK，讲了这么多原理，我们终于引出了我们的第一个可转化为代码的优化点——CSS 样式表规则的优化！</p>
<h2 id="不做无用功：基于渲染流程的-CSS-优化建议"><a href="#不做无用功：基于渲染流程的-CSS-优化建议" class="headerlink" title="不做无用功：基于渲染流程的 CSS 优化建议"></a>不做无用功：基于渲染流程的 CSS 优化建议</h2><p>在给出 CSS 选择器方面的优化建议之前，先告诉大家一个小知识：CSS 引擎查找样式表，对每条规则都按从右到左的顺序去匹配。 看如下规则：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#myList</span>  <span class="selector-tag">li</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这样的写法其实很常见。大家平时习惯了从左到右阅读的文字阅读方式，会本能地以为浏览器也是从左到右匹配 CSS 选择器的，因此会推测这个选择器并不会费多少力气：#myList 是一个 id 选择器，它对应的元素只有一个，查找起来应该很快。定位到了 myList 元素，等于是缩小了范围后再去查找它后代中的 li 元素，没毛病。</p>
<p>事实上，<strong>CSS 选择符是从右到左进行匹配的</strong>。我们这个看似“没毛病”的选择器，实际开销相当高：浏览器必须遍历页面上每个 li 元素，并且每次都要去确认这个 li 元素的父元素 id 是不是 myList，你说坑不坑！   </p>
<p>说到坑，不知道大家还记不记得这个经典的通配符：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>入门 CSS 的时候，不少同学拿通配符清除默认样式（我曾经也是通配符用户的一员）。但这个家伙很恐怖，它会匹配所有元素，所以浏览器必须去遍历每一个元素！大家低头看看自己页面里的元素个数，是不是心凉了——这得计算多少次呀！</p>
<p>这样一看，一个小小的 CSS 选择器，也有不少的门道！好的 CSS 选择器书写习惯，可以为我们带来非常可观的性能提升。根据上面的分析，我们至少可以总结出如下性能提升的方案：</p>
<ul>
<li><p>避免使用通配符，只对需要用到的元素进行选择。</p>
</li>
<li><p>关注可以通过继承实现的属性，避免重复匹配重复定义。</p>
</li>
<li><p>少用标签选择器。如果可以，用类选择器替代，举个🌰：  </p>
<p>  错误示范：</p>
  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#myList</span> <span class="selector-tag">li</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>  课代表：  </p>
  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.myList_li</span> &#123;&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>不要画蛇添足，id 和 class 选择器不应该被多余的标签选择器拖后腿。举个🌰：   </p>
<p>  错误示范   </p>
  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">myList</span><span class="selector-id">#title</span></span><br></pre></td></tr></table></figure>

<p>  课代表</p>
  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#title</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li>减少嵌套。后代选择器的开销是最高的，因此我们应该尽量将选择器的深度降到最低（最高不要超过三层），尽可能使用类来关联每一个标签元素。     </li>
</ul>
<p>搞定了 CSS 选择器，万里长征才刚刚开始的第一步。但现在你已经理解了浏览器的工作过程，接下来的征程对你来说并不再是什么难题~   </p>
<h2 id="告别阻塞：CSS-与-JS-的加载顺序优化"><a href="#告别阻塞：CSS-与-JS-的加载顺序优化" class="headerlink" title="告别阻塞：CSS 与 JS 的加载顺序优化"></a>告别阻塞：CSS 与 JS 的加载顺序优化</h2><p>说完了过程，我们来说一说特性。</p>
<p>HTML、CSS 和 JS，都具有<strong>阻塞渲染</strong>的特性。   </p>
<p>HTML 阻塞，天经地义——没有 HTML，何来 DOM？没有 DOM，渲染和优化，都是空谈。   </p>
<p>那么 CSS 和 JS 的阻塞又是怎么回事呢？   </p>
<h3 id="CSS-的阻塞"><a href="#CSS-的阻塞" class="headerlink" title="CSS 的阻塞"></a>CSS 的阻塞</h3><p>在刚刚的过程中，我们提到 DOM 和 CSSOM 合力才能构建渲染树。这一点会给性能造成严重影响：默认情况下，CSS 是阻塞的资源。浏览器在构建 CSSOM 的过程中，<strong>不会渲染任何已处理的内容</strong>。即便 DOM 已经解析完毕了，只要 CSSOM 不 OK，那么渲染这个事情就不 OK（这主要是为了避免没有 CSS 的 HTML 页面丑陋地“裸奔”在用户眼前）。   </p>
<p>我们知道，只有当我们开始解析 HTML 后、解析到 link 标签或者 style 标签时，CSS 才登场，CSSOM  的构建才开始。很多时候，DOM 不得不等待 CSSOM。因此我们可以这样总结：   </p>
<blockquote>
<p>CSS 是阻塞渲染的资源。需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。   </p>
</blockquote>
<p>事实上，现在很多团队都已经做到了尽早（将 CSS 放在 head 标签里）和尽快（启用 CDN 实现静态资源加载速度的优化）。这个“把 CSS 往前放”的动作，对很多同学来说已经内化为一种编码习惯。那么现在我们还应该知道，这个“习惯”不是空穴来风，它是由 CSS 的特性决定的。    </p>
<h3 id="JS-的阻塞"><a href="#JS-的阻塞" class="headerlink" title="JS 的阻塞"></a>JS 的阻塞</h3><p>不知道大家注意到没有，前面我们说过程的时候，花了很多笔墨去说 HTML、说 CSS。相比之下，JS 的出镜率也太低了点。<br>这当然不是因为 JS 不重要。而是因为，在首次渲染过程中，JS 并不是一个非登场不可的角色——没有 JS，CSSOM 和 DOM 照样可以组成渲染树，页面依然会呈现——即使它死气沉沉、毫无交互。   </p>
<p>JS 的作用在于<strong>修改</strong>，它帮助我们修改网页的方方面面：内容、样式以及它如何响应用户交互。这“方方面面”的修改，本质上都是对 DOM 和 CSSDOM 进行修改。因此 JS 的执行会阻止 CSSOM，在我们不作显式声明的情况下，它也会阻塞 DOM。    </p>
<p>我们通过一个🌰来理解一下这个机制：  </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS阻塞测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-id">#container</span> &#123;</span></span><br><span class="line">      background-color: yellow;</span><br><span class="line">      width: 100px;</span><br><span class="line">      height: 100px;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 尝试获取container元素</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">"container"</span>)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'container'</span>, container)</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 尝试获取container元素</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">"container"</span>)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'container'</span>, container)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 输出container元素此刻的背景色</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'container bgColor'</span>, getComputedStyle(container).backgroundColor)</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-id">#container</span> &#123;</span></span><br><span class="line">      background-color: blue;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">三个 console 的结果分别为：   </span><br><span class="line"></span><br><span class="line">![](https://user-gold-cdn.xitu.io/2018/9/28/166203a2d62212c9?w=1050&amp;h=254&amp;f=png&amp;s=27323)    </span><br><span class="line"></span><br><span class="line">注：本例仅使用了内联 JS 做测试。感兴趣的同学可以把这部分 JS 当做外部文件引入看看效果——它们的表现一致。</span><br><span class="line">   </span><br><span class="line">第一次尝试获取 id 为 container 的 DOM 失败，这说明 JS 执行时阻塞了 DOM，后续的 DOM 无法构建；第二次才成功，这说明脚本块只能找到在它前面构建好的元素。这两者结合起来，“阻塞 DOM”得到了验证。再看第三个 console，尝试获取 CSS 样式，获取到的是在 JS 代码执行前的背景色（yellow），而非后续设定的新样式（blue），说明 CSSOM 也被阻塞了。那么在阻塞的背后，到底发生了什么呢？    </span><br><span class="line">  </span><br><span class="line">我们前面说过，**JS 引擎是独立于渲染引擎存在的**。我们的 JS 代码在文档的何处插入，就在何处执行。当 HTML 解析器遇到一个 script 标签时，它会暂停渲染过程，将控制权交给 JS 引擎。JS 引擎对内联的 JS 代码会直接执行，对外部 JS 文件还要先获取到脚本、再进行执行。等 JS 引擎运行完毕，浏览器又会把控制权还给渲染引擎，继续 CSSOM 和 DOM 的构建。 因此与其说是 JS 把 CSS 和 HTML 阻塞了，不如说是 JS 引擎抢走了渲染引擎的控制权。       </span><br><span class="line">  </span><br><span class="line">现在理解了阻塞的表现与原理，我们开始思考一个问题。浏览器之所以让 JS 阻塞其它的活动，是因为它不知道 JS 会做什么改变，担心如果不阻止后续的操作，会造成混乱。但是我们是写 JS 的人，我们知道 JS 会做什么改变。假如我们可以确认一个 JS 文件的执行时机并不一定非要是此时此刻，我们就可以通过对它使用 defer 和 async 来避免不必要的阻塞，这里我们就引出了外部 JS 的三种加载方式。</span><br><span class="line"></span><br><span class="line">### JS的三种加载方式 </span><br><span class="line"></span><br><span class="line">- 正常模式： </span><br><span class="line">   </span><br><span class="line">   ```html</span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>这种情况下 JS 会阻塞浏览器，浏览器必须等待 index.js 加载和执行完毕才能去做其它事情。   </p>
<ul>
<li><p>async 模式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>async 模式下，JS 不会阻塞浏览器做任何其它的事情。它的加载是异步的，当它加载结束，JS 脚本会<strong>立即执行</strong>。   </p>
<ul>
<li><p>defer 模式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>defer 模式下，JS 的加载是异步的，执行是<strong>被推迟的</strong>。等整个文档解析完成、DOMContentLoaded 事件即将被触发时，被标记了 defer 的 JS 文件才会开始依次执行。   </p>
<p>从应用的角度来说，一般当我们的脚本与 DOM 元素和其它脚本之间的依赖关系不强时，我们会选用 async；当脚本依赖于 DOM 元素和其它脚本的执行结果时，我们会选用 defer。   </p>
<p>通过审时度势地向 script 标签添加 async/defer，我们就可以告诉浏览器在等待脚本可用期间不阻止其它的工作，这样可以显著提升性能。   </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们知道，当 JS 登场时，往往意味着对 DOM 的操作。DOM 操作所导致的性能开销的“昂贵”，大家可能早就有所耳闻，雅虎军规里很重要的一条就是“尽量减少 DOM 访问”。 </p>
<p>那么 DOM 到底为什么慢，我们如何去规避这种慢呢？这里我们就引出了下一个章节需要重点解释的两个概念：CSS 中的回流（Reflow）与重绘（Repaint）。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/28/webpack系列/webpack性能优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qicainiao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qicainiao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/28/webpack系列/webpack性能优化/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-28T18:41:57+08:00">
                2019-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/28/webpack系列/22webpack中第三方库library的打包/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qicainiao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qicainiao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/28/webpack系列/22webpack中第三方库library的打包/" itemprop="url">webpack系列-21webpack中环境变量的使用方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-28T18:33:41+08:00">
                2019-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前都是对自己写的业务代码进行打包，但假设我们要开发一个库，这样的库代码如何用webpack进行打包呢，首先我们创建一个非常简单的函数库</p>
<p>首先新建一个文件夹library，运行npm init -y，得到一个package.json<br>package.json</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">　　<span class="string">"name"</span>: <span class="string">"library"</span>,</span><br><span class="line">　　<span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">　　<span class="string">"description"</span>: <span class="string">""</span>,</span><br><span class="line">　　<span class="string">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">　　<span class="string">"scripts"</span>: &#123;</span><br><span class="line">　　&#125;,</span><br><span class="line">　　<span class="string">"keywords"</span>: [],</span><br><span class="line">　　<span class="string">"author"</span>: <span class="string">""</span>,</span><br><span class="line">　　<span class="string">"license"</span>: <span class="string">"MIT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后library下新建一个src,里面建三个文件,math.js,string.js,index.js</p>
<p>math.js</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> add(a,b) &#123;</span><br><span class="line">　　<span class="built_in">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> minus(a,b) &#123;</span><br><span class="line">　　<span class="built_in">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> cheng(a,b) &#123;</span><br><span class="line">　　<span class="built_in">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> chu(a,b) &#123;</span><br><span class="line">　　<span class="built_in">return</span> a / b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>string.js</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> join(a, b)&#123;</span><br><span class="line">　　<span class="built_in">return</span> a + <span class="string">''</span> + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>index.js</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import * as math from <span class="string">'./math'</span>;</span><br><span class="line">import * as string from <span class="string">'./string'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default &#123; math, string &#125;</span><br></pre></td></tr></table></figure>

<p>然后安装webpack</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli --save</span><br></pre></td></tr></table></figure>

<p>新建配置文件 webpack.config.js<br>webpack.config.js</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const path = require(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">　　mode: <span class="string">'production'</span>,</span><br><span class="line">　　entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">　　output: &#123;</span><br><span class="line">　　　　path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">　　　　filename: <span class="string">'library.js'</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>package.json里面配置script</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">　　<span class="string">"build"</span>: <span class="string">"webpack"</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>然后运行 npm run build。生成一个dist文件夹，里面生成了一个library.js。如果是我们业务代码，就好了。但是我们生成的是一个库，给别人用的，那么别人怎么用呢</p>
<p>第一种</p>
<p>import library from ‘library’;<br>第二种<br>const library = require(‘library’);<br>第三种</p>
<p>require([‘library’],function() {<br>})<br>如果我们的库想外面可以被这样引用。可以做一个配置,webpack.config.js里面output多加一个参数<br>webpack.config.js</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const path = require(<span class="string">'path'</span>);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">　　mode: <span class="string">'production'</span>,</span><br><span class="line">　　entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">　　output: &#123;</span><br><span class="line">　　　　path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">　　　　filename: <span class="string">'library.js'</span>,</span><br><span class="line">　　　　// 通过任何形式，都可以引用的到</span><br><span class="line">　　　　libraryTarget: <span class="string">'umd'</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了这种引用之外，我还希望别人通过引用srcipt后，可以通过全局变量来使用这个库</p>
<script src="library.js"></script>
<p>library.add();<br>再配置一下webpack.config.js</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const path = require(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">　　mode: <span class="string">'production'</span>,</span><br><span class="line">　　entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">　　output: &#123;</span><br><span class="line">　　　　path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">　　　　filename: <span class="string">'library.js'</span>,</span><br><span class="line">　　　　// 打包生成的代码挂载到页面到一个全局变量上</span><br><span class="line">　　　　library: <span class="string">'library'</span>,</span><br><span class="line">　　　　// 通过任何形式，都可以引用的到</span><br><span class="line">　　　　libraryTarget: <span class="string">'umd'</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们做一个测试，在生成好的dist目录下新建index.html</p>
<p>index.html</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">　　&lt;head&gt;</span><br><span class="line">　　　　&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">　　　　&lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">　　　　&lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"ie=edge"</span>&gt;</span><br><span class="line">　　　　&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">　　　　&lt;script src=<span class="string">"./library.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">　　&lt;/head&gt;</span><br><span class="line">　　&lt;body&gt;</span><br><span class="line">　　&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>然后运行这个页面，控制台调用library;</p>
<p>除了在打包库的时候，我们要额外的配置这两个参数之外呢，我们还要做一件事情。比如string.js<br>string.js</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> join(a, b)&#123;</span><br><span class="line">　　<span class="built_in">return</span> a + <span class="string">''</span> + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在写的时候发现lodash里面有个功能很好</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install lodash --save</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import _ from <span class="string">'lodash'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> join(a, b)&#123;</span><br><span class="line">　　<span class="built_in">return</span> _.join([a,b], <span class="string">' '</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后现在看起来没有问题，但是别人使用我们的库的时候，他也有可能重新使用了lodash。这就导致一个问题，我们的库里面打包了一次lodash，用户的业务代码里面又打包了一次lodash。所以用户的业务代码里面就容易存在两份lodash代码。为了解决这个问题，我们需要在库里面做一个另外的配置，externals</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const path = require(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">　　mode: <span class="string">'production'</span>,</span><br><span class="line">　　entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">　　// 如果打包过程中遇到lodash，就忽略这个库，不要打包到代码里面去</span><br><span class="line">　　externals: [<span class="string">'lodash'</span>],</span><br><span class="line">　　output: &#123;</span><br><span class="line">　　　　path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">　　　　filename: <span class="string">'library.js'</span>,</span><br><span class="line">　　　　// 打包生成的代码挂载到页面到一个全局变量上</span><br><span class="line">　　　　library: <span class="string">'library'</span>,</span><br><span class="line">　　　　// 通过任何形式，都可以引用的到</span><br><span class="line">　　　　libraryTarget: <span class="string">'umd'</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候外面直接使用library就不可以了，因为库里面要用lodash。所以在用这个库的时候，业务代码里面要另外引入lodash。</p>
<p>现在我们看下externals的作用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">externals : &#123;</span><br><span class="line">　　lodash : &#123;</span><br><span class="line">　　　　commonjs: <span class="string">'lodash'</span>,</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>这个意思是。如果lodash这个库在commonjs环境下被使用，lodash加载的时候，名字必须是lodash</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const lodash = require(<span class="string">'lodash'</span>);</span><br><span class="line"></span><br><span class="line">externals : &#123;</span><br><span class="line">　　lodash : &#123;</span><br><span class="line">　　　　root: <span class="string">'_'</span>,</span><br><span class="line">　　　　commonjs: <span class="string">'lodash'</span>,</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>这个时候加一个root。这个意思是如果既不使用commonjs，也不使用es module。更不用amd形式去引入lodash。这个lodash是通过js引入的，这里要求这个script标签必须注入一个叫做’_’的全局变量。但是一般来说没有特殊要求，直接配置成</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">externals : &#123;</span><br><span class="line">　　lodash :<span class="string">'lodash'</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>就可以了，他的意思是不管任何环境下，引入lodash都叫做lodash。</p>
<p>最终我们给别人使用的是最后的library,那怎么样让别人方便的使用到呢？<br>首先把package.json里面的入口文件配置改成</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"main"</span>: <span class="string">"./dist/library.js"</span>,</span><br></pre></td></tr></table></figure>

<p>然后npm里面注册一个账号。登录后在命令行输入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm adduser</span><br></pre></td></tr></table></figure>

<p>输入账号密码后，直接输入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure>

<p>成功后，别人利用npm install library就可以用你的了</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/28/webpack系列/21webpack中环境变量的使用方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qicainiao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qicainiao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/28/webpack系列/21webpack中环境变量的使用方法/" itemprop="url">webpack系列-21webpack中环境变量的使用方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-28T18:31:00+08:00">
                2019-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在webpack打包过程中，怎么去使用一些环境变量。<br>首先我有一个打包配置的三个文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">　　<span class="string">"dev-build"</span>: <span class="string">"webpack --profile --json &gt; stats.json --config ./build/webpack.dev.js"</span>,</span><br><span class="line">　　<span class="string">"dev"</span>: <span class="string">"webpack-dev-server --config ./build/webpack.dev.js"</span>,</span><br><span class="line">　　<span class="string">"build"</span>: <span class="string">"webpack --config ./build/webpack.prod.js"</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>对应三个命令，分别是开发环境的一个命令 npm run dev。打包生成开发环境代码的命令 npm run dev-build。以及线上代码生成的一个命令 npm run build。现在我要借助两个配置文件来帮助我们去完成对应的打包，分别是dev对应配置文件和prod对应的配置文件。现在我可以通过另外一种形式来对代码进行一次变更。</p>
<p>webpack.dev.js</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const webpack = require(<span class="string">'webpack'</span>);</span><br><span class="line">const merge = require(<span class="string">'webpack-merge'</span>);</span><br><span class="line">const commonConfig = require(<span class="string">'./webpack.common.js'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const devConfig = &#123;　　</span><br><span class="line">　　mode: <span class="string">'development'</span>,</span><br><span class="line">　　devtool: <span class="string">'cheap-module-eval-source-map'</span>,</span><br><span class="line">　　devServer: &#123;</span><br><span class="line">　　　　contentBase:<span class="string">'./dist'</span>,</span><br><span class="line">　　　　open:<span class="literal">true</span>,</span><br><span class="line">　　　　hot: <span class="literal">true</span></span><br><span class="line">　　&#125;,</span><br><span class="line">　　plugins: [</span><br><span class="line">　　　　new webpack.HotModuleReplacementPlugin()</span><br><span class="line">　　],</span><br><span class="line">　　output: &#123;</span><br><span class="line">　　　　filename: <span class="string">'[name].js'</span>,</span><br><span class="line">　　　　chunkFilename: <span class="string">'[name].chunk.js'</span>,</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = merge(commonConfig, devConfig);</span><br></pre></td></tr></table></figure>

<p>这是dev配置原始文件，其中引入了merge和commonConfig。现在我把他删掉，直接导出devConfig</p>
<p>webpack.dev.js</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const webpack = require(<span class="string">'webpack'</span>);</span><br><span class="line">const devConfig = &#123;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = devConfig;</span><br></pre></td></tr></table></figure>

<p>prod也做同样的处理，这样我导出的就不是融合过后的文件。而是自己独立的配置文件。接着我们打开webpack.common.js，去引入merge，dev和prod</p>
<p>webpack.common.js</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const path = require(<span class="string">'path'</span>);</span><br><span class="line">const HtmlWebpackPlugin = require(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line">const CleanWebpackPlugin = require(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line">const webpack = require(<span class="string">'webpack'</span>);</span><br><span class="line">const merge = require(<span class="string">'webpack-merge'</span>);</span><br><span class="line">const devConfig = require(<span class="string">'./webpack.dev'</span>);</span><br><span class="line">const prodConfig = require(<span class="string">'./webpack.prod'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const commonConfig = &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module.exports = (env) =&gt; &#123;</span><br><span class="line">　　// 如果有这个全局变量，且是线上环境，否则是开发环境</span><br><span class="line">　　<span class="keyword">if</span>(env &amp;&amp; env.production) &#123;</span><br><span class="line">　　　　<span class="built_in">return</span> merge(commonConfig, prodConfig);</span><br><span class="line">　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　<span class="built_in">return</span> merge(commonConfig, devConfig);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以前我们导出一个对象，这里我们导出一个函数，接收一个全局变量，怎么融合取决于传递进来的变量。是否有全局变量，是哪个环境决定</p>
<p>package.json</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">　　<span class="string">"dev-build"</span>: <span class="string">"webpack --profile --json &gt; stats.json --config ./build/webpack.common.js"</span>,</span><br><span class="line">　　<span class="string">"dev"</span>: <span class="string">"webpack-dev-server --config ./build/webpack.common.js"</span>,</span><br><span class="line">　　<span class="string">"build"</span>: <span class="string">"webpack --env.production --config ./build/webpack.common.js"</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>package.json里面走的都是webpack.common.js了。在build里面加入–env.production。其他不加默认走devConfig。各自运行。没问题。这样就不是通过不同的文件，而是都是走common，通过变量控制</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/28/webpack系列/19webpack与浏览器缓存，如果文件没有动打包hash那么不变/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qicainiao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qicainiao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/28/webpack系列/19webpack与浏览器缓存，如果文件没有动打包hash那么不变/" itemprop="url">webpack系列-19webpack与浏览器缓存</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-28T17:56:01+08:00">
                2019-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>根据之前的配置，假设文件上传至服务器中，没有加hash，如果页面内容有更改，浏览器刷新的时候，请求的还是原先的文件，也就是浏览器的缓存，因为名字没有变。现在我们在上线的webpack配置中加上hash</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output:&#123;</span><br><span class="line">　　filename: <span class="string">'[name].[contenthash].js'</span>,</span><br><span class="line">　　chunkFilename: <span class="string">'[name].[contenthash].js'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候打包出来的文件就有了hash值。只要文件内容不变，hash值就不变，内容变了才变。</p>
<p>如果打包失效，比如老版本的webpack4。这个时候加一个配置参数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">optimization:&#123;</span><br><span class="line">　　runtimeChunk: &#123;</span><br><span class="line">　　　　name: <span class="string">'runtime'</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/28/webpack系列/18webpack中css文件的代码分割和压缩/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qicainiao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qicainiao's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/28/webpack系列/18webpack中css文件的代码分割和压缩/" itemprop="url">webpack系列-18webpack中css文件的代码分割</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-28T17:47:20+08:00">
                2019-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">　　output: &#123;</span><br><span class="line">　　　　filename: <span class="string">'[name].js'</span>,</span><br><span class="line">　　　　chunkFilename: <span class="string">'[name].chunk.js'</span>,</span><br><span class="line">　　　　path: path.resolve(__dirname, <span class="string">'../dist'</span>)</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在看别人写的webpack，output配置项，肯跟会碰到chunkFilename这样的配置项，那这个是什么意思呢？filename和chunkFilename有什么区别呢？首先看个例子</p>
<p>index.html</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">　　&lt;head&gt;</span><br><span class="line">　　　　&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">　　　　&lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">　　　　&lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"ie=edge"</span>&gt;</span><br><span class="line">　　　　&lt;title&gt;html template&lt;/title&gt;</span><br><span class="line">　　&lt;/head&gt;</span><br><span class="line">　　&lt;body&gt;</span><br><span class="line">　　　　&lt;div id=<span class="string">'root'</span>&gt;&lt;/div&gt;</span><br><span class="line">　　&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>index.js</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">getComponent</span></span>() &#123;</span><br><span class="line">　　const &#123; default: _ &#125; = await import(/* webpackChunkName:<span class="string">'lodash'</span> */<span class="string">'lodash'</span>);</span><br><span class="line">　　const element = document.createElement(<span class="string">'div'</span>);</span><br><span class="line">　　element.innerHTML = _.join([<span class="string">'1'</span>, <span class="string">'2'</span>], <span class="string">'-'</span>);</span><br><span class="line">　　<span class="built_in">return</span> element</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.addEventListener(<span class="string">'click'</span>, ()=&gt; &#123;</span><br><span class="line">　　getComponent().<span class="keyword">then</span>( element =&gt;&#123;</span><br><span class="line">　　　　document.body.appendChild(element);</span><br><span class="line">　　&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>webpack.common.js</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">　　entry: &#123;</span><br><span class="line">　　　　main: <span class="string">'./src/index.js'</span></span><br><span class="line">　　&#125;,</span><br><span class="line">　　output: &#123;</span><br><span class="line">　　　　filename: <span class="string">'[name].js'</span>,</span><br><span class="line">　　　　chunkFilename: <span class="string">'[name].chunk.js'</span>,</span><br><span class="line">　　　　path: path.resolve(__dirname, <span class="string">'../dist'</span>)</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行npm run dev-build打包。打开dist目录，发现第三方模块打包好的名字叫vendors<del>lodash.chunk.js，不再是之前的vendors</del>lodash.js。我们的入口文件对应的都是filename的输出。如果不是入口文件，是异步引入或者间接产生的js文件，他就会走chunkFilename这个输出的配置参数。</p>
<p>接下来进入主题，css代码的分割<br>index.html</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">　　&lt;head&gt;</span><br><span class="line">　　　　&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">　　　　&lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">　　　　&lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"ie=edge"</span>&gt;</span><br><span class="line">　　　　&lt;title&gt;html template&lt;/title&gt;</span><br><span class="line">　　&lt;/head&gt;</span><br><span class="line">　　&lt;body&gt;</span><br><span class="line">　　　　&lt;div id=<span class="string">'root'</span>&gt;&lt;/div&gt;</span><br><span class="line">　　&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>index.js</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import <span class="string">'./style.css'</span>;</span><br><span class="line">console.log(<span class="string">' hello world '</span>);</span><br></pre></td></tr></table></figure>

<p>style.css</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">　　background: <span class="comment">#abcdef;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行npm run dev-build。发现打包生成的文件只有main.js 和 vendors~main.chunk.js。但是浏览器打开index.html。背景已经有了。这是怎么回事呢？webpack在做css的打包的时候，会直接打包到js里面</p>
<p>如果我希望在打包生成代码的时候，如果我引入了css文件，那么把css文件打包到dist目录下。而不是直接引入到js文件里面。那么就需要引入一个插件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://webpack.js.org/plugins/mini-css-extract-plugin</span><br><span class="line"></span><br><span class="line">npm install --save-dev mini-css-extract-plugin</span><br></pre></td></tr></table></figure>

<p>这个插件可以对css进行代码分割。这个插件不适合开发环境，因为官网说了，这个插件现在还暂时不支持热更新。</p>
<p>安装好之后看怎么使用，首先要在webpack中引入这个插件。首先打开线上配置文件</p>
<p>webpack.prod.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">const merge = require(&apos;webpack-merge&apos;);</span><br><span class="line">const commonConfig = require(&apos;./webpack.common.js&apos;);</span><br><span class="line">const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;);</span><br><span class="line"></span><br><span class="line">const prodConfig = &#123;</span><br><span class="line">　　mode: &apos;production&apos;,</span><br><span class="line">　　devtool: &apos;cheap-module-source-map&apos;,</span><br><span class="line">　　module: &#123;</span><br><span class="line">　　　　rules:[&#123;</span><br><span class="line">　　　　　　test: /\.scss$/,</span><br><span class="line">　　　　　　use: [</span><br><span class="line">　　　　　　　　MiniCssExtractPlugin.loader,</span><br><span class="line">　　　　　　　　&#123;</span><br><span class="line">　　　　　　　　　　loader: &apos;css-loader&apos;,</span><br><span class="line">　　　　　　　　　　options: &#123;</span><br><span class="line">　　　　　　　　　　　　importLoaders: 2</span><br><span class="line">　　　　　　　　　　&#125;</span><br><span class="line">　　　　　　　　&#125;,</span><br><span class="line">　　　　　　　　&apos;sass-loader&apos;,</span><br><span class="line">　　　　　　　　&apos;postcss-loader&apos;</span><br><span class="line">　　　　　　]</span><br><span class="line">　　　　&#125;,&#123;</span><br><span class="line">　　　　　　test: /\.css$/,</span><br><span class="line">　　　　　　use: [</span><br><span class="line">　　　　　　　　MiniCssExtractPlugin.loader,</span><br><span class="line">　　　　　　　　&apos;css-loader&apos;,</span><br><span class="line">　　　　　　　　&apos;postcss-loader&apos;</span><br><span class="line">　　　　　　]</span><br><span class="line">　　　　&#125;]</span><br><span class="line">　　&#125;,</span><br><span class="line">　　plugins:[</span><br><span class="line">　　　　new MiniCssExtractPlugin(&#123;&#125;)</span><br><span class="line">　　]</span><br><span class="line">&#125;</span><br><span class="line">module.exports = merge(commonConfig, prodConfig);</span><br></pre></td></tr></table></figure>

<p>然后对应到webpack.common.js里面删除css,scss相关到配置。运行npm run build。发现多出了两个文件main.css 和 main.css.map</p>
<p>css打包好后，是未压缩的，要将打包好的css进行压缩，安装，optimize-css-assets-webpack-plugin</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install optimize-css-assets-webpack-plugin -D</span><br></pre></td></tr></table></figure>

<p>在webpack.props.js引入并配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const OptimizeCSSAssetsPlugin = require(&apos;optimize-css-assets-webpack-plugin&apos;);</span><br><span class="line">　　module.exports = &#123;</span><br><span class="line">　　　　optimization: &#123;</span><br><span class="line">　　　　　　minimizer: [new OptimizeCSSAssetsPlugin(&#123;&#125;)],</span><br><span class="line">　　　　&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行 npm run build。会发现css文件被自动的合并压缩。</p>
<p>还有更高级的用法， 假设有很多个css，要打包到一个css文件里面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://webpack.js.org/plugins/mini-css-extract-plugin</span><br></pre></td></tr></table></figure>

<p>也可以实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">　　splitChunks: &#123;</span><br><span class="line">　　　　cacheGroups: &#123;</span><br><span class="line">　　　　　　styles: &#123;</span><br><span class="line">　　　　　　　　name: &apos;styles&apos;,</span><br><span class="line">　　　　　　　　test: /\.css$/,</span><br><span class="line">　　　　　　　　chunks: &apos;all&apos;,</span><br><span class="line">　　　　　　　　enforce: true, // 忽略到前面到配置，不管是minSize,maxSize等等，只要是css，都打包到同一个文件中</span><br><span class="line">　　　　　　&#125;,</span><br><span class="line">　　　　&#125;,</span><br><span class="line">　　&#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">qicainiao</p>
              <p class="site-description motion-element" itemprop="description">Hello World!</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">40</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">qicainiao</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
